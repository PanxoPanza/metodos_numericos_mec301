
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>1.6 Algortimos de búsqueda de raíces &#8212; MEC301 - Métodos Numéricos</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="1.5 Series de Taylor" href="../1.5-Taylor-series/1.5-Taylor-series.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">MEC301 - Métodos Numéricos</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Bienvenidos al curso
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Parte 1. Introducción a los métodos numéricos
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../1.1-Aspectos_generales/1.1-Aspectos_generales.html">
   1.1 Aspectos generales de programación y algoritmos
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1.2-Algebra_lineal/1.2-Algebra_lineal.html">
   1.2 Algebra lineal y sistemas de ecuaciones lineales
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1.3-Ajuste_de_curvas/1.3-Ajuste_de_curvas.html">
   1.3 Ajuste de curvas por mínimos cuadrados
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1.4-Interpolacion/1.4-Interpolacion.html">
   1.4 Métodos de Interpolación
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../1.5-Taylor-series/1.5-Taylor-series.html">
   1.5 Series de Taylor
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   1.6 Algortimos de búsqueda de raíces
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/executablebooks/jupyter-book/master?urlpath=tree/1.6-Root-finding/1.6-Root-finding.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/1.6-Root-finding/1.6-Root-finding.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduccion">
   Introducción
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#busqueda-de-raices-para-una-funcion-escalar">
   Busqueda de raíces para una función escalar
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#metodos-de-intervalo-acotado-biseccion">
     Métodos de intervalo acotado: Bisección
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#metodos-de-intervalo-acotado-newton-raphson">
     Métodos de intervalo acotado: Newton-Raphson
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#metodos-combinados">
     Métodos combinados
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#error-relativo-y-absorluto">
     Error relativo y absorluto
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#busqueda-de-raices-de-funcion-escalar-en-python">
     Búsqueda de raíces de función escalar en python
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#busqueda-de-raices-para-funciones-vectoriales">
   Busqueda de raíces para funciones vectoriales
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#metodos-de-busqueda-lineal">
     Métodos de búsqueda lineal
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metodos-de-region-de-confianza">
   Métodos de región de confianza
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#busqueda-de-raices-de-funcion-vectorial-en-python">
     Búsqueda de raíces de función vectorial en python
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#referencias">
   Referencias
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>1.6 Algortimos de búsqueda de raíces</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduccion">
   Introducción
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#busqueda-de-raices-para-una-funcion-escalar">
   Busqueda de raíces para una función escalar
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#metodos-de-intervalo-acotado-biseccion">
     Métodos de intervalo acotado: Bisección
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#metodos-de-intervalo-acotado-newton-raphson">
     Métodos de intervalo acotado: Newton-Raphson
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#metodos-combinados">
     Métodos combinados
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#error-relativo-y-absorluto">
     Error relativo y absorluto
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#busqueda-de-raices-de-funcion-escalar-en-python">
     Búsqueda de raíces de función escalar en python
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#busqueda-de-raices-para-funciones-vectoriales">
   Busqueda de raíces para funciones vectoriales
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#metodos-de-busqueda-lineal">
     Métodos de búsqueda lineal
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metodos-de-region-de-confianza">
   Métodos de región de confianza
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#busqueda-de-raices-de-funcion-vectorial-en-python">
     Búsqueda de raíces de función vectorial en python
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#referencias">
   Referencias
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <p><font size="6">MEC301 - Métodos Numéricos</font></p>
<section class="tex2jax_ignore mathjax_ignore" id="algortimos-de-busqueda-de-raices">
<h1>1.6 Algortimos de búsqueda de raíces<a class="headerlink" href="#algortimos-de-busqueda-de-raices" title="Permalink to this headline">#</a></h1>
<p><br><br><br><br>
Profesor: Francisco Ramírez Cuevas<br>
Fecha: 5 de Septiembre 2022</p>
<section id="introduccion">
<h2>Introducción<a class="headerlink" href="#introduccion" title="Permalink to this headline">#</a></h2>
<p>Consideremos el problema de caída de presión <span class="math notranslate nohighlight">\(\Delta P\)</span> al mover un fluído con densidad <span class="math notranslate nohighlight">\(\rho\)</span> y viscosidad cinemática <span class="math notranslate nohighlight">\(\nu\)</span>, a través de una tubería de largo <span class="math notranslate nohighlight">\(L\)</span>.</p>
<a class="reference internal image-reference" href="../_images/presure_drop.png"><img alt="../_images/presure_drop.png" class="align-center" src="../_images/presure_drop.png" style="width: 350px;" /></a>
<p>Para un fluido que fluye a una velocidad <span class="math notranslate nohighlight">\(V\)</span>,la caída de presión está dada por:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\frac{\Delta P}{\rho g} =f \frac{L}{D}\frac{V^2}{2g}
\end{equation*}\]</div>
<p>donde <span class="math notranslate nohighlight">\(f\)</span> es el factor de fricción.</p>
<p>Para determinar <span class="math notranslate nohighlight">\(f\)</span> debemos resolver la ecuación de Colebrook:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\frac{1}{\sqrt{f}} = -2.0\log\left(\frac{\varepsilon/D}{3.7} + \frac{2.51}{\mathrm{Re}\sqrt{f}}\right)
\end{equation*}\]</div>
<p>donde <span class="math notranslate nohighlight">\(\mathrm{Re} = \frac{VD}{\nu}\)</span> es el número de Reynolds, y <span class="math notranslate nohighlight">\(\varepsilon/D\)</span> la rugosidad relativa.</p>
<p>Sin embargo, esta ecuación no se puede resolver analíticamente. ¿Como resolvemos esta ecuación?</p>
<p>Llamamos raíces de una función <span class="math notranslate nohighlight">\(f(x)\)</span> a los valores <span class="math notranslate nohighlight">\(x^*\)</span> tales que <span class="math notranslate nohighlight">\(f(x^*) = 0\)</span>.</p>
<p>Determinar <span class="math notranslate nohighlight">\(f\)</span> a partir de la ecuación de Colebrook es equivalente a encontrar las raíces de la función:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
f(x) = \frac{1}{\sqrt{x}} + 2.0\log\left(\frac{\varepsilon/D}{3.7} + \frac{2.51}{\mathrm{Re}\sqrt{x}}\right)
\end{equation*}\]</div>
<p>En esta unidad revisaremos los aspectos generales de los algoritmos para busqueda de raíces de una función.</p>
</section>
<section id="busqueda-de-raices-para-una-funcion-escalar">
<h2>Busqueda de raíces para una función escalar<a class="headerlink" href="#busqueda-de-raices-para-una-funcion-escalar" title="Permalink to this headline">#</a></h2>
<p>Una función escalar es una función con una o más variables dependientes, que entrega un valor unidimencional.</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
f: x\in \mathbb{R}^n \rightarrow \mathbb{R}
\end{equation*}\]</div>
<p>Resolver una ecuación unidimiencional es equivalente a encontrar las raices de una función escalar con una variable dependiente, <span class="math notranslate nohighlight">\(f(x) = 0\)</span>.</p>
<p>En esta sección veremos los métodos más conocidos para resolver este problema</p>
<section id="metodos-de-intervalo-acotado-biseccion">
<h3>Métodos de intervalo acotado: Bisección<a class="headerlink" href="#metodos-de-intervalo-acotado-biseccion" title="Permalink to this headline">#</a></h3>
<p>El método de la bisección es un <strong>método de intervalo acotado</strong>. Se basa en el teorema del valor intermedio</p>
<blockquote>
<div><p><strong>Teorema del valor intermedio</strong> para una función <span class="math notranslate nohighlight">\(f(x)\)</span> continua en entre los puntos <span class="math notranslate nohighlight">\(a\)</span> y <span class="math notranslate nohighlight">\(b\)</span>, tal que <span class="math notranslate nohighlight">\(f(a)f(b) &lt; 0\)</span>, existe un valor <span class="math notranslate nohighlight">\(c\)</span>, <span class="math notranslate nohighlight">\(a&lt;c&lt;b\)</span>, tal que <span class="math notranslate nohighlight">\(f(c) = 0\)</span>.</p>
</div></blockquote>
<a class="reference internal image-reference" href="../_images/valor_intermedio.png"><img alt="../_images/valor_intermedio.png" class="align-center" src="../_images/valor_intermedio.png" style="width: 250px;" /></a>
<p>Para un intervalo <span class="math notranslate nohighlight">\(x\in [a,b]\)</span>, tal que <span class="math notranslate nohighlight">\(f(a)f(b) &lt; 0\)</span>, el método de la bisección consiste en acotar el intervalo evaluando el punto medio <span class="math notranslate nohighlight">\(f(m)\)</span>, con <span class="math notranslate nohighlight">\(m = \frac{a+b}{2}\)</span>.</p>
<ul class="simple">
<li><p>Si <span class="math notranslate nohighlight">\(f(m)f(a) &lt; 0\)</span> el nuevo interfalo es <span class="math notranslate nohighlight">\(x\in [a,m]\)</span>, de lo contrario, <span class="math notranslate nohighlight">\(x\in [m, b]\)</span></p></li>
</ul>
<p>El algoritmo continua acotando el intervalo hasta encontrar la raíz de <span class="math notranslate nohighlight">\(f(x)\)</span>.</p>
<a class="reference internal image-reference" href="../_images/bisection.png"><img alt="../_images/bisection.png" class="align-center" src="../_images/bisection.png" style="width: 400px;" /></a>
<p>Creemos una función en python para calcular raíces por medio del método de la bisección</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">def</span> <span class="nf">bisection</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span>
    <span class="c1"># imprimimos el intervalo en cada iteración</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(a,b) = (</span><span class="si">%.3f</span><span class="s1">, </span><span class="si">%.3f</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
    
    <span class="c1"># primero, verificamos si el intervalo [a,b]</span>
    <span class="c1"># satisface el teorema del valor medio</span>
    <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;El intervalo [a, b] no contiene raices&quot;</span><span class="p">)</span>
    
    <span class="c1"># determinamos el punto medio entre [a, b]</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="p">:</span> <span class="c1"># si |f(m)| &lt; tol, m = x0</span>
        
        <span class="c1"># si no, evaluamos el intervalo acotado más cercano a x0</span>
        <span class="k">if</span>   <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">b</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">elif</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">m</span>
        
        <span class="c1"># llamamos a bisection recursivamente</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">bisection</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">tol</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">m</span> 
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Análisis de intervalos&#39;</span><span class="p">)</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="c1"># intervalo [a,b]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a = </span><span class="si">%.3f</span><span class="s1">, f(a) = </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;b = </span><span class="si">%.3f</span><span class="s1">, f(b) = </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Resultado método de Bisección&#39;</span><span class="p">)</span>
<span class="n">tol</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="c1"># valor de tolerancia</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">bisection</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">tol</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x* = </span><span class="si">%.5f</span><span class="s1">, f(x*) = </span><span class="si">%.3e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="n">f</span><span class="p">(</span><span class="n">x0</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Análisis de intervalos
a = -1.000, f(a) = -0.632
b = 1.000, f(b) = 1.718
Resultado método de Bisección
(a,b) = (-1.000, 1.000)
(a,b) = (-1.000, 0.000)
(a,b) = (-1.000, -0.500)
(a,b) = (-0.750, -0.500)
(a,b) = (-0.750, -0.625)
(a,b) = (-0.750, -0.688)
(a,b) = (-0.719, -0.688)
x* = -0.70312, f(x*) = 6.511e-04
</pre></div>
</div>
</div>
</div>
</section>
<section id="metodos-de-intervalo-acotado-newton-raphson">
<h3>Métodos de intervalo acotado: Newton-Raphson<a class="headerlink" href="#metodos-de-intervalo-acotado-newton-raphson" title="Permalink to this headline">#</a></h3>
<p>El método de Newton-Raphson es un <strong>método de intervalo abierto</strong>. El método se origina a partir de series de Taylor.</p>
<p>Supongamos que <span class="math notranslate nohighlight">\(x_0\)</span> es un punto cercano a la raíz de una función <span class="math notranslate nohighlight">\(f(x)\)</span>. Mediante la aproximación lineal, la raíz de la función <span class="math notranslate nohighlight">\(x_1\)</span> debe satisfacer la ecuación:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
0 = f(x_0) + f^{\prime}(x_0)(x_1-x_0),
\end{equation*}\]</div>
<p>Es decir, la raíz de <span class="math notranslate nohighlight">\(f(x)\)</span> está dada por:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
x_1 = x_0 - \frac{f(x_0)}{f^{\prime}(x_0)}
\end{equation*}\]</div>
<p>Si <span class="math notranslate nohighlight">\(x_1\)</span> no es la raíz, podemos encontrar un nuevo valor mediante <span class="math notranslate nohighlight">\(x_2 = x_1 - \frac{f(x_1)}{f^{\prime}(x_1)}\)</span></p>
<p>En resumen, el método de Newton-Raphson se define mediante la operación iterativa:</p>
<div class="amsmath math notranslate nohighlight" id="equation-d77a4033-f4a8-4e1f-bc55-0504bc83b05c">
<span class="eqno">(11)<a class="headerlink" href="#equation-d77a4033-f4a8-4e1f-bc55-0504bc83b05c" title="Permalink to this equation">#</a></span>\[\begin{equation}
x_{k+1} = x_k - \frac{f(x_k)}{f^{\prime}(x_k)}
\end{equation}\]</div>
<p>Gráficamente, lo que hacemos en cada iteración es encontrar el punto <span class="math notranslate nohighlight">\(x_{k+1}\)</span> donde la recta <span class="math notranslate nohighlight">\(f(x_k) + f^{\prime}(x_k)(x-x_k)\)</span> intersecta el eje <span class="math notranslate nohighlight">\(y = 0\)</span>.</p>
<a class="reference internal image-reference" href="../_images/newton_raphson.png"><img alt="../_images/newton_raphson.png" class="align-center" src="../_images/newton_raphson.png" style="width: 300px;" /></a>
<p>La ventaja de este algoritmo es que, a diferencia de los métodos por intervalo acotado, solo necesita de un valor inicial. Esta es una caracterísca general de los métodos de intervalo abierto.</p>
<p>Una segunda ventaja radica en la rápida convergencia del algoritmo para encontrar soluciones.</p>
<a class="reference internal image-reference" href="../_images/newton_raphson_good.gif"><img alt="../_images/newton_raphson_good.gif" class="align-center" src="../_images/newton_raphson_good.gif" style="width: 600px;" /></a>
<center> Fuente <a href="https://medium.com/@SereneBiologist/finding-beauty-in-bad-algorithms-799af003aee8/">Finding Beauty in Bad Algorithms</a></center><p>Esta es una característica general de los métodos de intervalo abierto.</p>
<p>Otros métodos de intervalo abierto se diferencian de Newton-Raphson en la forma de determinar <span class="math notranslate nohighlight">\(f'(x)\)</span>. Esto debido a que no siempre es posible determinar la derviada de forma analítica.</p>
<p>Por ejemplo, en el <strong>método de la secante</strong>, mediante la aproximación <span class="math notranslate nohighlight">\(f'(x_k) = \frac{f(x_k) - f(x_{k-1})}{x_k - x_{k-1}}\)</span>, aplica la siguiente fórmula de iteración:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
x_{k+1} = x_k - \frac{f(x_k)(x_k - x_{k-1})}{f(x_k) - f(x_{k-1})}
\end{equation*}\]</div>
<p>Notar que, debido a esta fórmula, el método de la secante requiere <strong>dos valores iniciales, <span class="math notranslate nohighlight">\(x_0\)</span> y <span class="math notranslate nohighlight">\(x_1\)</span></strong></p>
<p>Una desventaja de los métodos de intervalo abierto es que pueden sufrir serios problemas de convergencia si el valor <span class="math notranslate nohighlight">\(x_k\)</span> cae en un punto de la función donde <span class="math notranslate nohighlight">\(f'(x_k) \approx 0\)</span></p>
<p>En esta animación vemos como el número de iteraciones “<span class="math notranslate nohighlight">\(n\)</span>” aumenta considerablemente debido a problemas de convergencia en los puntos <span class="math notranslate nohighlight">\(f'(x_k) \approx 0\)</span>. En la notación, <span class="math notranslate nohighlight">\(y = f(x_k)\)</span>
<a class="reference internal" href="../_images/newton_raphson_bad.gif"><img alt="../_images/newton_raphson_bad.gif" class="align-center" src="../_images/newton_raphson_bad.gif" style="width: 600px;" /></a></p>
<center> Fuente <a href="https://medium.com/@SereneBiologist/finding-beauty-in-bad-algorithms-799af003aee8/">Finding Beauty in Bad Algorithms</a></center><p>Además, estos métodos no tienen control sobre la raíz encontrada.</p>
<p>Por ejemplo, la función <span class="math notranslate nohighlight">\(f(x) = f(x) = x^3 - 100x^2 - x + 100\)</span> tiene dos raíces <span class="math notranslate nohighlight">\(x^* = 1\)</span> y <span class="math notranslate nohighlight">\(x^* = 100\)</span>. Analicemos como Newton-Raphson entrega distintas soluciones dependiendo del valor inicial <span class="math notranslate nohighlight">\(x_0\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">def</span> <span class="nf">newton_raphson</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
    <span class="n">nIter</span> <span class="o">=</span> <span class="mi">1</span>       <span class="c1"># número de iteraciones</span>
    <span class="n">niter_max</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># número máximo de iteraciones (util cuando usamos &quot;while&quot;)</span>
    
    <span class="c1"># Newton-Raphson iterativo</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">nIter</span> <span class="o">&lt;</span> <span class="n">niter_max</span><span class="p">:</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span><span class="o">/</span><span class="n">df</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        
        <span class="c1"># actualizamos x0, el error y número de iteraciones</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">x1</span>
        <span class="n">nIter</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c1"># si nIter &gt; niter_max y la solución no converge </span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;La solución no converge&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x0</span><span class="p">,</span> <span class="n">nIter</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span>  <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">100</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">100</span>

<span class="n">df</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">200</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">x0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">tol</span> <span class="o">=</span> <span class="mf">0.001</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x* = </span><span class="si">%.3f</span><span class="s1">, N. de iteraciones = </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> 
      <span class="n">newton_raphson</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">tol</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>x* = 100.000, N. de iteraciones = 2
</pre></div>
</div>
</div>
</div>
<p>Notamos que:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{eqnarray*}
&amp;&amp;\mathrm{si~} x_0 = 0 &amp;\rightarrow&amp; x^* = 100. \\
&amp;&amp;\mathrm{si~} x_0 = 0.01 &amp;\rightarrow&amp; x^* = 1.
\end{eqnarray*}\]</div>
<p>Esto sucede debido a que <span class="math notranslate nohighlight">\(f'(0) = -1\)</span>. Así, para el valor inicial <span class="math notranslate nohighlight">\(x_0 = 0\)</span>, la segunda iteración nos da <span class="math notranslate nohighlight">\(x_1 = 0 - \frac{100}{-1} = 100\)</span>, que es una raíz de <span class="math notranslate nohighlight">\(f(x)\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%capture</span> showplot
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mf">110.1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>           <span class="c1"># Tamaño de figura</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">18</span><span class="p">})</span> <span class="c1"># Tamaño de fuente</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;f(x)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Gráfica de $x^3 - 100x^2 - x + 100$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">showplot</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/1.6-Root-finding_42_0.png" src="../_images/1.6-Root-finding_42_0.png" />
</div>
</div>
</section>
<section id="metodos-combinados">
<h3>Métodos combinados<a class="headerlink" href="#metodos-combinados" title="Permalink to this headline">#</a></h3>
<p>Los metodos más sofisticados para búsqueda de raices combinan métodos de intervalo abierto y cerrado. Por un lado, el método de intervalo abierto permite una convergencia más rápida, mientras que el método de intervalo cerrado permite acotar la solución.</p>
<p>En términos generales, los métodos combinados operan de la siguente forma.</p>
<ul class="simple">
<li><p>Se subdivide el dominio de la función para identificar intervalos donde existan raices.</p></li>
<li><p>Se procede con la iteración mediante un método de intervalo abierto</p></li>
<li><p>Si la solución se mueve fuera del intervalo acotado, se procede a iterar con un método de intervalo cerrado.</p></li>
</ul>
<p>Por ejemplo, el <strong>método de Brent’s</strong> combina un método de intervalo abierto, como Newton-Raphson o el método de la secante, con el método de la bisección. Más información en las referencias</p>
</section>
<section id="error-relativo-y-absorluto">
<h3>Error relativo y absorluto<a class="headerlink" href="#error-relativo-y-absorluto" title="Permalink to this headline">#</a></h3>
<p>En los códigos de bisección y Newton-Raphson definimos el criterio de convergencia <span class="math notranslate nohighlight">\(f(x_0) = 0\)</span>. Sin embargo, este criterio no es correcto, ya que la definición de <span class="math notranslate nohighlight">\(f(x_0) \approx 0\)</span> es relativa a la escala de <span class="math notranslate nohighlight">\(f(x)\)</span> en el dominio donde estemos trabajando. Dicho de otra manera, para cualquier punto <span class="math notranslate nohighlight">\(x_i\)</span>, siempre tendremos <span class="math notranslate nohighlight">\(f(x_i)\approx 0\)</span> si nos alejamos lo suficiente de la gráfica de la función.</p>
<p>Un criterio más adecuado, en cambio, sería definir el error relavo al valor exácto de la raíz <span class="math notranslate nohighlight">\(x^*\)</span>. Sin embargo, debido a que este valor es deconocido, definimos el <strong>error absoluto</strong> para cada nuevo valor <span class="math notranslate nohighlight">\(x_{k+1}\)</span> como:</p>
<div class="amsmath math notranslate nohighlight" id="equation-0423b45b-1b3c-4ec8-8ec3-f36659b4c7ce">
<span class="eqno">(12)<a class="headerlink" href="#equation-0423b45b-1b3c-4ec8-8ec3-f36659b4c7ce" title="Permalink to this equation">#</a></span>\[\begin{equation}
|x_{k+1} -x_{k}|
\end{equation}\]</div>
<p>Alternativamente, podemos definir el <strong>error relativo</strong> de la forma:</p>
<div class="amsmath math notranslate nohighlight" id="equation-407b08d5-ef4f-4636-931d-f1296006d672">
<span class="eqno">(13)<a class="headerlink" href="#equation-407b08d5-ef4f-4636-931d-f1296006d672" title="Permalink to this equation">#</a></span>\[\begin{equation}
\frac{|x_{k+1} -x_{k}|}{|x_{k+1}|}
\end{equation}\]</div>
<p>En general, no existe una regla respecto al tipo de error que se debe usar como criterio de convergencia. La recomendación es usar el error absoluto se tiene conocimiento de la función. Esto porque, a veces, el error relativo puede imponer condiciones demaciado estrictas para la convergencia.</p>
</section>
<section id="busqueda-de-raices-de-funcion-escalar-en-python">
<h3>Búsqueda de raíces de función escalar en python<a class="headerlink" href="#busqueda-de-raices-de-funcion-escalar-en-python" title="Permalink to this headline">#</a></h3>
<p>En python, la función <code class="docutils literal notranslate"><span class="pre">root_scalar</span></code> de la librería <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code>, permite determinar raíces de una función escalar. Esta función tiene implementada distintos métodos de intervalo abierto, cerrado y combinados, tales como: bisección, Newton-Raphson, secante y Brent’s.</p>
<p>Así, la función puede aceptar:</p>
<ul class="simple">
<li><p>Un valor inicial <span class="math notranslate nohighlight">\(x_0\)</span>, y la derivada</p></li>
<li><p>Dos valores iniciales <span class="math notranslate nohighlight">\(x_0\)</span> y <span class="math notranslate nohighlight">\(x_1\)</span></p></li>
<li><p>Un intervalo.</p></li>
</ul>
<p>Dependiendo de este input, la función decide el tipo de método más adecuado.</p>
<p>También podemos especificar el tipo de método a utilizar mediante la instrucción <code class="docutils literal notranslate"><span class="pre">method='tipo_de_metodo'</span></code> como argumento en la función</p>
<p>Por ejemplo, analizamos la raíz de la función <span class="math notranslate nohighlight">\(f(x) = x^3 - 1\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">root_scalar</span>
<span class="n">f</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># función a resolver</span>
<span class="n">df</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span>   <span class="c1"># derivada</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Bisección:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;bisect&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Newton-Raphson:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x0</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="n">fprime</span><span class="o">=</span><span class="n">df</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;newton&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Secante:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x0</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="n">x1</span><span class="o">=</span><span class="mf">0.21</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;secant&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Bisección:
       converged: True
           flag: &#39;converged&#39;
 function_calls: 43
     iterations: 41
           root: 1.0000000000004547
Newton-Raphson:
       converged: True
           flag: &#39;converged&#39;
 function_calls: 22
     iterations: 11
           root: 1.0
Secante:
       converged: True
           flag: &#39;converged&#39;
 function_calls: 23
     iterations: 22
           root: 1.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Brent´s:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;brentq&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Intervalo (método por defecto):</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cond. inicial y derivada (método po defecto):</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x0</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="n">fprime</span><span class="o">=</span><span class="n">df</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Brent´s:
       converged: True
           flag: &#39;converged&#39;
 function_calls: 11
     iterations: 10
           root: 1.0
Intervalo (método por defecto):
       converged: True
           flag: &#39;converged&#39;
 function_calls: 11
     iterations: 10
           root: 1.0
Cond. inicial y derivada (método po defecto):
       converged: True
           flag: &#39;converged&#39;
 function_calls: 22
     iterations: 11
           root: 1.0
</pre></div>
</div>
</div>
</div>
<p>Si hacemos <code class="docutils literal notranslate"><span class="pre">sol</span> <span class="pre">=</span> <span class="pre">root_scalar</span></code>, la variable <code class="docutils literal notranslate"><span class="pre">sol</span></code> almacena la información de la función:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sol</span> <span class="o">=</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;raíz x*=</span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sol</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;número de iteraciones </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sol</span><span class="o">.</span><span class="n">iterations</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>raíz x*=1.000
número de iteraciones 10
</pre></div>
</div>
</div>
</div>
<p>También podemos extraer el valor de la raíz directamente mediante <code class="docutils literal notranslate"><span class="pre">root_scalar(...).root</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;raíz x*=</span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>raíz x*=1.000
</pre></div>
</div>
</div>
</div>
<p>Para controlar la tolerancia en <code class="docutils literal notranslate"><span class="pre">root_scalar</span></code> podemos usar:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xtol</span></code> para el error absoluto, por ejemplo:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sol</span> <span class="o">=</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1E-5</span><span class="p">)</span> <span class="c1"># error absoluto de 0.00001 </span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rtol</span></code> para el error realtivo, por ejemplo:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sol</span> <span class="o">=</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">rtol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span> <span class="c1"># error relativo de 0.1%</span>
</pre></div>
</div>
<p>También podemos usar combinaciones de ambas. En ese caso, la iteración finalizará cuando se cumpla cualquiera de los dos criterios.</p>
<p>Por último, también podemos definir el numero máximo de iteraciones mediante <code class="docutils literal notranslate"><span class="pre">maxiter</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sol</span> <span class="o">=</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span> <span class="c1"># máximo 1000 iteraciones</span>
</pre></div>
</div>
<p>Para mayor información revisar la <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root_scalar.html">documentación oficial</a>.</p>
</section>
</section>
<section id="busqueda-de-raices-para-funciones-vectoriales">
<h2>Busqueda de raíces para funciones vectoriales<a class="headerlink" href="#busqueda-de-raices-para-funciones-vectoriales" title="Permalink to this headline">#</a></h2>
<p>Una función vectorial es una función con una o más variables dependientes, que entrega un vector de múltiples dimensiones.</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
f: x\in \mathbb{R}^n \rightarrow \mathbb{R}^m
\end{equation*}\]</div>
<p>Consideremos el siguiente sistema de ecuaciones:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
x\log(y^2-1) &amp;= 3 \\
y\sin(2x^3) + e^y &amp;= 2
\end{align*}\]</div>
<p>Resolver este sistema, es equivalente a encontrar las raices de una función vetorial del tipo:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\vec{F}(x,y) = \Bigg\{
\begin{matrix}
f(x,y) &amp;= x\log(y^2-1) - 3 \\
g(x,y) &amp;= y\sin(2x^3) + e^y - 2
\end{matrix}
\end{equation*}\]</div>
<p>Así, resolver un sistema de ecuaciones de <span class="math notranslate nohighlight">\(n\)</span> incognitas, es equivalente a encontrar las raices de una función vectorial del tipo:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
f: x\in \mathbb{R}^n \rightarrow \mathbb{R}^n
\end{equation*}\]</div>
<p>En este capítulo revisaremos los aspectos generales de los métodos numéricos para resolver este problema.</p>
<section id="metodos-de-busqueda-lineal">
<h3>Métodos de búsqueda lineal<a class="headerlink" href="#metodos-de-busqueda-lineal" title="Permalink to this headline">#</a></h3>
<p>Para un vector <span class="math notranslate nohighlight">\(\vec{x} = \{x_1, x_2, ... x_n\}\)</span>, y una función vectorial <span class="math notranslate nohighlight">\(\vec{F}\left(\vec{x}\right) = \big\{f_1\left(\vec{x}\right),f_2\left(\vec{x}\right), ... f_n\left(\vec{x}\right)\big\}\)</span>, consideremos la forma generalizada del método de Newton-Raphson:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\vec{x}_k = \vec{x}_{k-1} - {\left[\bar{J}(\vec{x}_{k-1})\right]}^{-1}\cdot \vec{F}\left(\vec{x}_{k-1}\right) 
\end{equation*}\]</div>
<p>donde <span class="math notranslate nohighlight">\(\bar{J} = \nabla\vec{F}\)</span> es el <strong>Jacobiano</strong> de <span class="math notranslate nohighlight">\(\vec{F}\)</span>.</p>
<p>Por ejemplo, para una función vectorial <span class="math notranslate nohighlight">\(\vec{F}(x,y) = \big\{f(x,y), g(x,y)\big\}\)</span>:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\bar{J}(x,y) = 
\left[
\begin{matrix}
\frac{\partial f}{\partial x} &amp; \frac{\partial f}{\partial y} \\
\frac{\partial g}{\partial x} &amp; \frac{\partial g}{\partial y}
\end{matrix}\right]
\end{equation*}\]</div>
<p>En términos simples, el Jacobiano es la derivada de una función vectorial.</p>
<p>En otras palabras, el método generalizado de Newton-Raphson consiste en encontrar un nuevo vector <span class="math notranslate nohighlight">\(\vec{x}_{k+1}\)</span> a partir de la pendiente descendiente definida en el vector <span class="math notranslate nohighlight">\(\vec{x}_{k}\)</span>.</p>
<p>Sin embargo, a diferencia del caso unidimensional, el Jacobiano entrega multiples direcciones posibles. ¿Como saber cuál es la dirección que minimiza <span class="math notranslate nohighlight">\(\vec{F}\)</span>?</p>
<p>Para definir la dirección descendiente se considera el criterio:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\mathrm{min}[f] = \mathrm{min}\left[\vec{F}\cdot\vec{F}\right] 
\end{equation*}\]</div>
<p>Así, el problema de busqueda de raíces de una función vectorial se transforma en un problema de minimización.</p>
<p>Esta es la estrategia de los métodos de Búsqueda lineal.</p>
<p>Entre los más conocidos tenemos el <strong>método de Broyden</strong>. Más información en las referencias</p>
</section>
</section>
<section id="metodos-de-region-de-confianza">
<h2>Métodos de región de confianza<a class="headerlink" href="#metodos-de-region-de-confianza" title="Permalink to this headline">#</a></h2>
<p>Un problema de los métodos de busqueda lineal está en el cálculo del Jacobiano de la función. Los métodos de región de confianza se basan en una aproximación de <span class="math notranslate nohighlight">\(\vec{F}\)</span> en forma de paraboloide. Esta aproximación simplifica el cálculo del Jacobiano.</p>
<p>Se define como <strong>región de confianza a la región donde la función puede ser aproximada por un parabolide</strong>.</p>
<p>En términos generales, los métodos de región de confianza operan de la siguiente forma:</p>
<ul class="simple">
<li><p>Se define una región de confianza inicial y se busca un mínimo dentro esa región.</p></li>
<li><p>Si el valor encontrado miniza <span class="math notranslate nohighlight">\(\vec{F}\cdot\vec{F}\)</span>, se construye una aproximación hyperboloide de <span class="math notranslate nohighlight">\(\vec{F}\)</span> y se incrementa la región de confianza.</p></li>
<li><p>Si el valor encontrado no miniza <span class="math notranslate nohighlight">\(\vec{F}\cdot\vec{F}\)</span>, se reduce la región de confianza, y se vuelve a buscar el mínimo.</p></li>
<li><p>El algoritmo itera hasta encontrar un mínimo global de <span class="math notranslate nohighlight">\(\vec{F}\)</span>.</p></li>
</ul>
<p>En general, los métodos de región de confianza son más estables que los métodos de búsqueda lineal, y son los métodos por defecto en funciones de python.</p>
<p>Mayor información sobre estos métodos <a class="reference external" href="http://www.applied-mathematics.net/optimization/optimizationIntro.html">acá</a></p>
<section id="busqueda-de-raices-de-funcion-vectorial-en-python">
<h3>Búsqueda de raíces de función vectorial en python<a class="headerlink" href="#busqueda-de-raices-de-funcion-vectorial-en-python" title="Permalink to this headline">#</a></h3>
<p>En python, la función <code class="docutils literal notranslate"><span class="pre">fsolve</span></code> de la librería <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code> permite encontrar las raíces de una función vectorial.</p>
<p>La función se basa en los algoritmos de región de confianza “hybrd” y “hybrj” de la libreria <code class="docutils literal notranslate"><span class="pre">MINPACK</span></code>. Más detalles <a class="reference external" href="https://www.math.utah.edu/software/minpack/minpack/hybrj.html">acá</a></p>
<p>La función <code class="docutils literal notranslate"><span class="pre">fsolve</span></code> requiere, como mínimo, la función vectorial, y los valores iniciales.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fsolve</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;la solución es: &#39;</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>la solución es:  [6.50409711 0.90841421]
</pre></div>
</div>
</div>
</div>
<p>También podemos definir el error absoluto mediante la instrucción <code class="docutils literal notranslate"><span class="pre">xtol</span></code> (por defecto, <code class="docutils literal notranslate"><span class="pre">xtol=1.49012e-08</span></code>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xtol</span> <span class="o">=</span> <span class="mf">1E-10</span><span class="p">)</span> <span class="c1"># |xk+1 - xk| &lt; 1E-10</span>
</pre></div>
</div>
</section>
</section>
<section id="referencias">
<h2>Referencias<a class="headerlink" href="#referencias" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p>Kong Q., Siauw T., Bayen A. M. <strong>Chapter 19: Root Finding</strong> in <em><a class="reference external" href="https://pythonnumericalmethods.berkeley.edu/notebooks/chapter17.00-Interpolation.html">Python Programming and Numerical Methods – A Guide for Engineers and Scientists</a></em>, 1st Ed., Academic Press, 2021</p></li>
<li><p>Chapra S., Canale R. <strong>Parte dos: Raíces de ecuaciones</strong> en <em>Métodos Numéricos para Ingenieros</em>, 6ta Ed., McGraw Hill, 2011</p></li>
<li><p>Williams H. P. <strong>Chapter 9: Root Finding and Nonlinear Sets of Equations</strong> in “Numerical Recipes” 3rd Ed, Cambridge University Press, 2007</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./1.6-Root-finding"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../1.5-Taylor-series/1.5-Taylor-series.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">1.5 Series de Taylor</p>
        </div>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Francisco V. Ramirez-Cuevas<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>