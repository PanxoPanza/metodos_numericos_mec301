%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{MEC501 - Manejo y conversión de energía solar térmica}
\date{Aug 08, 2022}
\release{}
\author{Francisco V.\@{} Ramirez\sphinxhyphen{}Cuevas}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\sphinxAtStartPar
This is a small sample book to give you a feel for how book content is
structured.
It shows off a few of the major file types, as well as some sample content.
It does not go in\sphinxhyphen{}depth into any particular topic \sphinxhyphen{} check out \sphinxhref{https://jupyterbook.org}{the Jupyter Book documentation} for more information.

\sphinxAtStartPar
Check out the content pages bundled with this sample book to see more.
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales::doc}]{\sphinxcrossref{Unidad 1.1 Aspectos generales de programación y algoritmos}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal::doc}]{\sphinxcrossref{1.2 Algebra lineal y sistemas de ecuaciones lineales}}}

\end{itemize}

\sphinxstepscope

\sphinxAtStartPar
MEC301 \sphinxhyphen{} Metodos Numéricos


\chapter{Unidad 1.1 Aspectos generales de programación y algoritmos}
\label{\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales:unidad-1-1-br-aspectos-generales-de-programacion-y-algoritmos}}\label{\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales::doc}}
\sphinxAtStartPar

Profesor: Francisco Ramírez Cuevas
Fecha: 1 de Agosto 2022




\section{Complejidad de algoritmos}
\label{\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales:complejidad-de-algoritmos}}

\subsection{¿Qué es un algoritmo?}
\label{\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales:que-es-un-algoritmo}}
\sphinxAtStartPar
Un algoritmo es una serie ordenada de operaciones sistemáticas que permite hacer un cálculo y hallar la solución de un tipo de problemas.

\sphinxAtStartPar
Por ejemplo:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{out} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{out} \PYG{o}{+}\PYG{o}{=} \PYG{n}{i}\PYG{o}{*}\PYG{n}{j}
    \PYG{k}{return} \PYG{n}{out}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
La complejidad de un algoritmo es la \sphinxstylestrong{relación entre el tamaño del input \(N\)} y la \sphinxstylestrong{cantidad de operaciones para completarlo}.
Una forma de determinar la complejidad del algoritmo es \sphinxstylestrong{contabilizar las operaciones básicas}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
sumas

\item {} 
\sphinxAtStartPar
restas

\item {} 
\sphinxAtStartPar
multiplicaciones

\item {} 
\sphinxAtStartPar
divisiones

\item {} 
\sphinxAtStartPar
asignación de variables

\item {} 
\sphinxAtStartPar
llamados a otras funciones

\end{itemize}

\sphinxAtStartPar
Por ejemplo, en el siguiente algoritmo:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{out} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{out} \PYG{o}{+}\PYG{o}{=} \PYG{n}{i}\PYG{o}{*}\PYG{n}{j}
    \PYG{k}{return} \PYG{n}{out}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
El número de operaciones son:
\begin{itemize}
\item {} 
\sphinxAtStartPar
sumas: \(N^2\)

\item {} 
\sphinxAtStartPar
restas: 0

\item {} 
\sphinxAtStartPar
multiplicaciones: \(N^2\)

\item {} 
\sphinxAtStartPar
divisiones: 0

\item {} 
\sphinxAtStartPar
asignación de variables: \(2N^2 + N + 1\)

\item {} 
\sphinxAtStartPar
llamados a otras funciones: 0

\end{itemize}

\sphinxAtStartPar
Así, el \sphinxstylestrong{total de operaciónes} para completar el algoritmo es \(4N^2+N+1\).


\subsection{Notación \sphinxstyleemphasis{Big\sphinxhyphen{}O}}
\label{\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales:notacion-big-o}}
\sphinxAtStartPar
A medida que el tamaño de \(N\) aumenta, las operaciones de mayor orden se hacen dominantes. Así, podemos decir que la complejidad del algoritmo anterior es del orden \(O(N^2)\). Esta notación, denominada \sphinxstyleemphasis{\sphinxstylestrong{Big\sphinxhyphen{}O}}, es comúnmente utiilzada para \sphinxstylestrong{determinar la complejidad del algoritmo cuando \(N\) es de gran tamaño}.
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Nota} Un algoritmo tiene complejidad \sphinxstylestrong{polynomial} cuando es del tipo \(O(N^c)\), donde \(c\) es una constante.
\end{quote}

\sphinxAtStartPar
Analicemos la complejidad del siguiente algortimo:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}divide\PYGZus{}by\PYGZus{}two}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    
    \PYG{n}{out} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{while} \PYG{n}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{n}{n} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n}{out} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
        
    \PYG{k}{return} \PYG{n}{out}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
A medida que \(N\) crece podemos ver que la parte dominante de este algoritmo esta dentro de la operación \sphinxcode{\sphinxupquote{while}}.

\sphinxAtStartPar
Si analizamos el número de iteraciones \(I\) para un determinado \(N\), notaremos que estos están en la relacción \(N/2^I = 1\), es decir \(I\approx \log N\). Así, la complejidad de este algoritmo es \(O(\log N)\).
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Nota} Un algoritmo tiene complejidad \sphinxstylestrong{logaritmica} cuando es del tipo \(O(\log N)\).
\end{quote}


\subsection{Serie de Fibonacci y complejidad exponencial}
\label{\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales:serie-de-fibonacci-y-complejidad-exponencial}}
\sphinxAtStartPar
Una operación matemática puede ser ejecutada mediante algoritmos con diferente complejidad. Por ejemplo, consideremos la serie de Fibonacci.



\sphinxAtStartPar
Esta operación puede ejecutarse de dos maneras: (1) de forma iterativa, (2) de forma recursiva

\sphinxAtStartPar
\sphinxstylestrong{(1) Forma iterativa.} complejidad \(O(N)\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}fib\PYGZus{}iter}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    
    \PYG{n}{out} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
    
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{out}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{out}\PYG{p}{[}\PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{n}{out}\PYG{p}{[}\PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{out}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}fib\PYGZus{}iter}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
8
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{(2) Forma recursiva.} complejidad \(O\left(2^N\right)\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}fib\PYGZus{}rec}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    
    \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{:}
        \PYG{n}{out} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{out} \PYG{o}{=} \PYG{n}{my\PYGZus{}fib\PYGZus{}rec}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n}{my\PYGZus{}fib\PYGZus{}rec}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}
        
    \PYG{k}{return} \PYG{n}{out}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}fib\PYGZus{}rec}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
8
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Nota} Un algoritmo tiene complejidad \sphinxstylestrong{exponencial} cuando es del tipo \(O(c^N)\), donde \(c\) es una constante.
\end{quote}


\subsection{Notación \sphinxstyleemphasis{Big\sphinxhyphen{}O} y tiempo de computación}
\label{\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales:notacion-big-o-y-tiempo-de-computacion}}
\sphinxAtStartPar
La complejidad en la notación \sphinxstyleemphasis{Big\sphinxhyphen{}O} nos entrega una referencia del tiempo computacional dedicado para un determinado algoritmo.



\sphinxAtStartPar
Así, por ejemplo, si consideramos un procesador Intel i7\sphinxhyphen{}12700K \sphinxhyphen{} 5GHz \sphinxstyleemphasis{(\(\approx\) 5 billones de operaciones por segundo)}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{my\_fib\_iter(100)}} tomaría \(\approx\) 0.2 nanosegundos


\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{my\_fib\_recur(100)}} tomaría \(\approx\) 8 trillones de años

\end{itemize}

\sphinxAtStartPar
Podemos evaluar el tiempo de ejecución con la sentencia \sphinxcode{\sphinxupquote{\%time}}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{time} a = my\PYGZus{}fib\PYGZus{}iter(30)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CPU times: user 10 µs, sys: 2 µs, total: 12 µs
Wall time: 15 µs
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{time} a = my\PYGZus{}fib\PYGZus{}rec(30) \PYGZsh{}Nota. No probar N\PYGZgt{}30
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CPU times: user 216 ms, sys: 0 ns, total: 216 ms
Wall time: 216 ms
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{nota} En general, se deben evitar los algoritmos de complejidad exponencial
\end{quote}


\section{Representación binaria y errores de reondeo}
\label{\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales:representacion-binaria-y-errores-de-reondeo}}
\sphinxAtStartPar
En un computador, la información es almacenada en formato binario. Un \sphinxstylestrong{bit} puede tener dos valores: 0 o 1.
El computador es capaz de interpretar número utilizando códigos binarios.

\sphinxAtStartPar
Por ejemplo, el código de 8 bits \(001000101\) es equivalente a:
\label{equation:1.1-Aspectos_generales/1.1-Aspectos_generales:1d57c331-25e1-49c6-bdb2-009ad8a835b1}\begin{equation}
 0\cdot2^7 + 0\cdot2^6 + 1\cdot2^5 + 0\cdot2^4 + 0\cdot2^3 + 1\cdot2^2 + 0\cdot2^1 + 1\cdot2^0 = 37
\end{equation}
\sphinxAtStartPar
Cada variable tiene una cantidad de bits asociada.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Tipo
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Nombre
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Número de bits
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Rango de valores
\\
\hline
\sphinxAtStartPar
bool
&
\sphinxAtStartPar
Boolean
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{True}} o \sphinxcode{\sphinxupquote{Flase}}
\\
\hline
\sphinxAtStartPar
int32
&
\sphinxAtStartPar
Single precision integer
&
\sphinxAtStartPar
32
&
\sphinxAtStartPar
\sphinxhyphen{}2147483648 a 2147483647
\\
\hline
\sphinxAtStartPar
float64
&
\sphinxAtStartPar
Double presition float
&
\sphinxAtStartPar
64
&
\sphinxAtStartPar
\((-1)^s2^{e - 1024}\left(1 + f\right)\) \(s\): 1 bit;  \(e\): 11 bits;  \(f\): 52 bits
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
En python el tipo de variable se asigna dinámicamente. El número de bits depende de la versión de Python y el formato de la máquina en número de bits. Por ejemplo, para una máquina de 64 bits:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{type}\PYG{p}{(}\PYG{l+m+mi}{34}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}int64}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
int
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{type}\PYG{p}{(}\PYG{l+m+mf}{0.4e8}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}float64}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
float
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Usando “Numpy”, podemos controlar el número de bits asignados a una determinada variable

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{int16}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([0], dtype=int16)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Redondeo en variables tipo \sphinxstyleliteralintitle{\sphinxupquote{float}}}
\label{\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales:redondeo-en-variables-tipo-float}}
\sphinxAtStartPar
En variables tipo \sphinxcode{\sphinxupquote{float}}, para un determinado número de bits, existe un máximo y mínimo valor que puede ser representado. En Python, valores mayores o menores a estos son representados como \sphinxcode{\sphinxupquote{inf}} o \sphinxcode{\sphinxupquote{0}}, respectivamente.

\sphinxAtStartPar
Podemos deterinar estos límites mediante la librería \sphinxcode{\sphinxupquote{sys}}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{float\PYGZus{}info}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sys.float\PYGZus{}info(max=1.7976931348623157e+308, max\PYGZus{}exp=1024, max\PYGZus{}10\PYGZus{}exp=308, min=2.2250738585072014e\PYGZhy{}308, min\PYGZus{}exp=\PYGZhy{}1021, min\PYGZus{}10\PYGZus{}exp=\PYGZhy{}307, dig=15, mant\PYGZus{}dig=53, epsilon=2.220446049250313e\PYGZhy{}16, radix=2, rounds=1)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{2e+308} \PYG{c+c1}{\PYGZsh{}mayor al maximo 1.7976931348623157e+308}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
inf
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{1e\PYGZhy{}324} \PYG{c+c1}{\PYGZsh{} menor al mínimo no normalizado 5e\PYGZhy{}324}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Mínimo no normalizado}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{float\PYGZus{}info}\PYG{o}{.}\PYG{n}{min} \PYG{o}{*} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{float\PYGZus{}info}\PYG{o}{.}\PYG{n}{epsilon}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
5e\PYGZhy{}324
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Errores de redondeo en variables tipo \sphinxstyleliteralintitle{\sphinxupquote{float}}}
\label{\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales:errores-de-redondeo-en-variables-tipo-float}}
\sphinxAtStartPar
Las \sphinxstylestrong{variables del tipo \sphinxcode{\sphinxupquote{int}}} no son divisibles y, por lo tanto, \sphinxstylestrong{no sufren errores de redondeo}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{5} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Sin embargo, una \sphinxstylestrong{variable del tipo \sphinxcode{\sphinxupquote{float}}} es divisible. Esto significa que existe una cantidad de dígitos significativos reservados para un número, lo que \sphinxstylestrong{puede inducir errores de redondeo}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mf}{0.1} \PYG{o}{+} \PYG{l+m+mf}{0.2} \PYG{o}{+} \PYG{l+m+mf}{0.3} \PYG{o}{==} \PYG{l+m+mf}{0.6}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Para este tipo de operaciones es recomendable utilizar la función \sphinxcode{\sphinxupquote{round}}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{round}\PYG{p}{(}\PYG{l+m+mf}{0.1} \PYG{o}{+} \PYG{l+m+mf}{0.2} \PYG{o}{+} \PYG{l+m+mf}{0.3}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{round}\PYG{p}{(}\PYG{l+m+mf}{0.6}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Acumulacion de errores de reondeo}
\label{\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales:acumulacion-de-errores-de-reondeo}}
\sphinxAtStartPar
Cuando un código ejecuta una secuencia de operaciones, los errores de redonde suelen amplficarse.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Si ejecutamos esta operación una vez}
\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}and\PYGZus{}subtract}\PYG{p}{(}\PYG{n}{iterations}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{result} \PYG{o}{=} \PYG{l+m+mi}{1}
    
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{iterations}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{result} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{3}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{iterations}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{result} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{3}
    \PYG{k}{return} \PYG{n}{result}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}and\PYGZus{}subtract}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Si ejecutamos esta operación 100 veces}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.0000000000000002
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}and\PYGZus{}subtract}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Si ejecutamos esta operación 1000 veces}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.0000000000000064
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}and\PYGZus{}subtract}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Si ejecutamos esta operación 10000 veces}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1.0000000000001166
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Identificación de errores y debugging}
\label{\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales:identificacion-de-errores-y-debugging}}
\sphinxAtStartPar
Cuando los códigos de programación son grandes, a veces es necesario utlizar herramientas de \sphinxstyleemphasis{\sphinxstylestrong{debugging}}. Estas herramientas nos permiten revisar las distintas etapas dentro de un algoritmo.

\sphinxAtStartPar
Podemos llamar al debugger agregando mediante la librería \sphinxstyleemphasis{python debugger} \sphinxcode{\sphinxupquote{pdb}}.

\sphinxAtStartPar
Por ejemplo, consideremos la siguiente función

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{square\PYGZus{}number}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{sq} \PYG{o}{=} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
    \PYG{n}{sq} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}
    
    \PYG{k}{return} \PYG{n}{sq}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{square\PYGZus{}number}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{/}\PYG{n}{tmp}\PYG{o}{/}\PYG{n}{ipykernel\PYGZus{}217}\PYG{o}{/}\PYG{l+m+mf}{2602675188.}\PYG{n}{py} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{square\PYGZus{}number}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n+nn}{/tmp/ipykernel\PYGZus{}217/2802720476.py} in \PYG{n+ni}{square\PYGZus{}number}\PYG{n+nt}{(x)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{k}{def} \PYG{n+nf}{square\PYGZus{}number}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{2}     \PYG{n}{sq} \PYG{o}{=} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{3}     \PYG{n}{sq} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{4} 
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{5}     \PYG{k}{return} \PYG{n}{sq}

\PYG{n+ne}{TypeError}: unsupported operand type(s) for ** or pow(): \PYGZsq{}str\PYGZsq{} and \PYGZsq{}int\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Agregando la sentencia \sphinxcode{\sphinxupquote{\%pdb on}} antes de llamar la función podemos analizar el codigo y detectar posibles fuentes de error.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} llamamos al debugger de python}
\PYG{o}{\PYGZpc{}}\PYG{k}{pdb} on
\PYG{n}{square\PYGZus{}number}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Automatic pdb calling has been turned ON
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{n+nn}{Input In [27],} in \PYG{n+ni}{\PYGZlt{}cell line: 3\PYGZgt{}}\PYG{n+nt}{()}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{} llamamos al debugger de python}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{n}{get\PYGZus{}ipython}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{run\PYGZus{}line\PYGZus{}magic}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{on}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{3} \PYG{n}{square\PYGZus{}number}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n+nn}{Input In [25],} in \PYG{n+ni}{square\PYGZus{}number}\PYG{n+nt}{(x)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{k}{def} \PYG{n+nf}{square\PYGZus{}number}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{2}     \PYG{n}{sq} \PYG{o}{=} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{3}     \PYG{n}{sq} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{5}     \PYG{k}{return} \PYG{n}{sq}

\PYG{n+ne}{TypeError}: unsupported operand type(s) for ** or pow(): \PYGZsq{}str\PYGZsq{} and \PYGZsq{}int\PYGZsq{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{} \PYG{Color+ColorBold+ColorBoldGreen}{c:\PYGZbs{}users\PYGZbs{}francisco.ramirez.c\PYGZbs{}appdata\PYGZbs{}local\PYGZbs{}temp\PYGZbs{}ipykernel\PYGZus{}13000\PYGZbs{}2802720476.py}(2)\PYG{Color+ColorCyan}{square\PYGZus{}number}\PYG{Color+ColorBold+ColorBoldBlue}{()}

ipdb\PYGZgt{} help

Documented commands (type help \PYGZlt{}topic\PYGZgt{}):
========================================
EOF    commands   enable    ll        pp       s                until 
a      condition  exit      longlist  psource  skip\PYGZus{}hidden      up    
alias  cont       h         n         q        skip\PYGZus{}predicates  w     
args   context    help      next      quit     source           whatis
b      continue   ignore    p         r        step             where 
break  d          interact  pdef      restart  tbreak         
bt     debug      j         pdoc      return   u              
c      disable    jump      pfile     retval   unalias        
cl     display    l         pinfo     run      undisplay      
clear  down       list      pinfo2    rv       unt            

Miscellaneous help topics:
==========================
exec  pdb

ipdb\PYGZgt{} h a
a(rgs)
        Print the argument list of the current function.
ipdb\PYGZgt{} a
x = \PYGZsq{}10\PYGZsq{}
ipdb\PYGZgt{} h p
p expression
        Print the value of the expression.
ipdb\PYGZgt{} p x**2
*** TypeError: unsupported operand type(s) for ** or pow(): \PYGZsq{}str\PYGZsq{} and \PYGZsq{}int\PYGZsq{}
ipdb\PYGZgt{} p locals()
\PYGZob{}\PYGZsq{}x\PYGZsq{}: \PYGZsq{}10\PYGZsq{}\PYGZcb{}
ipdb\PYGZgt{} quit
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} detenemos el debugger}
\PYG{o}{\PYGZpc{}}\PYG{k}{pdb} off
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Automatic pdb calling has been turned OFF
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
También podemos agregar \sphinxstyleemphasis{breakpoints} en distintas líneas de código para detener el \sphinxstyleemphasis{debugger}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pdb}
\PYG{k}{def} \PYG{n+nf}{square\PYGZus{}number}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    
    \PYG{n}{pdb}\PYG{o}{.}\PYG{n}{set\PYGZus{}trace}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} agregamos un 1er breakpoint}
    \PYG{n}{sq} \PYG{o}{=} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
    
    \PYG{n}{pdb}\PYG{o}{.}\PYG{n}{set\PYGZus{}trace}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} agregamos un 2do breakpoint}
    
    \PYG{n}{sq} \PYG{o}{+}\PYG{o}{=} \PYG{n}{x}
    
    \PYG{k}{return} \PYG{n}{sq}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{square\PYGZus{}number}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{} \PYG{Color+ColorBold+ColorBoldGreen}{c:\PYGZbs{}users\PYGZbs{}francisco.ramirez.c\PYGZbs{}appdata\PYGZbs{}local\PYGZbs{}temp\PYGZbs{}ipykernel\PYGZus{}13000\PYGZbs{}1502937933.py}(5)\PYG{Color+ColorCyan}{square\PYGZus{}number}\PYG{Color+ColorBold+ColorBoldBlue}{()}

ipdb\PYGZgt{} a
x = 3
ipdb\PYGZgt{} p locals()
\PYGZob{}\PYGZsq{}x\PYGZsq{}: 3\PYGZcb{}
ipdb\PYGZgt{} sq
*** NameError: name \PYGZsq{}sq\PYGZsq{} is not defined
ipdb\PYGZgt{} continue
\PYGZgt{} \PYG{Color+ColorBold+ColorBoldGreen}{c:\PYGZbs{}users\PYGZbs{}francisco.ramirez.c\PYGZbs{}appdata\PYGZbs{}local\PYGZbs{}temp\PYGZbs{}ipykernel\PYGZus{}13000\PYGZbs{}1502937933.py}(9)\PYG{Color+ColorCyan}{square\PYGZus{}number}\PYG{Color+ColorBold+ColorBoldBlue}{()}

ipdb\PYGZgt{} p locals()
\PYGZob{}\PYGZsq{}x\PYGZsq{}: 3, \PYGZsq{}sq\PYGZsq{}: 9\PYGZcb{}
ipdb\PYGZgt{} sq
9
ipdb\PYGZgt{} p sq \PYGZhy{} x
6
ipdb\PYGZgt{} quit
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Algunos comandos útiles de \sphinxcode{\sphinxupquote{pdb}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{help}}: lista de todos los comandos del debugger

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{h }} \sphinxstyleemphasis{\#comando}: detalle del funcionamiento de un comando en específico

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} o \sphinxcode{\sphinxupquote{args}}: muestra el valor del argumento de la función

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{p}}: imprime el valor de una expresión específica. Usar \sphinxcode{\sphinxupquote{locals()}} para mostrar valor de variables locales

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pdb.trace()}}: agrega un \sphinxstyleemphasis{breakpoint} (pausa en el código)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{continue}}: continua con el código despues de un \sphinxstyleemphasis{breakpoint}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{quit}}: finaliza el debugger.

\end{itemize}


\section{Referencias}
\label{\detokenize{1.1-Aspectos_generales/1.1-Aspectos_generales:referencias}}
\sphinxAtStartPar
Kong Q., Siauw T., Bayen A. M. “\sphinxhref{https://pythonnumericalmethods.berkeley.edu/notebooks/Index.html}{Python Programming and Numerical Methods – A Guide for Engineers and Scientists}”, 1st Ed., Academic Press, 2021
\begin{itemize}
\item {} 
\sphinxAtStartPar
Capitulo 8 (Complejidad de algoritmos)

\item {} 
\sphinxAtStartPar
Capítulo 9 (Representación binaria y errores de redondeo)

\item {} 
\sphinxAtStartPar
Calítulo 10 (Identificación de errores y debugging)

\end{itemize}

\sphinxstepscope

\sphinxAtStartPar
MEC301 \sphinxhyphen{} Metodos Numéricos


\chapter{1.2 Algebra lineal y sistemas de ecuaciones lineales}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:algebra-lineal-y-sistemas-de-ecuaciones-lineales}}\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal::doc}}
\sphinxAtStartPar

Profesor: Francisco Ramírez Cuevas
Fecha: 8 de Agosto 2022




\section{Introducción a los sistemas de ecuaciones lineales}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:introduccion-a-los-sistemas-de-ecuaciones-lineales}}
\sphinxAtStartPar
Consideremos el caso de tres personas conectada por cuerdas elásticas.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{bungee_man}.png}\hspace*{\fill}}

\sphinxAtStartPar
En la primera figura (a), los tres cuerpos están en la posición inicial de forma que los elásticos están totalmente extendidos, \sphinxstylestrong{pero no estirados}. Definimos el cambio en la posición inicial de cada persona, como: \(x_1\), \(x_2\), \(x_3\).

\sphinxAtStartPar
Cuando los cuerpos se dejan caer, los elásticos se extienden por la gravedad y cada cuerpo toma la posición indicada en (b).

\sphinxAtStartPar
Analizamos el cambio en la posición de cada persona utilizando la ley de Newton:

\sphinxAtStartPar
\sphinxstyleemphasis{Diagrama de cuerpo libre}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{bungee_man_solve}.png}\hspace*{\fill}}
\begin{align*}
m_1\frac{d^2 x_1}{dt^2} &= m_1g + k_2(x_2 - x_1) - k_1 x_1 \\
m_2\frac{d^2 x_2}{dt^2} &= m_2g + k_3(x_3 - x_2) - k_2 (x_1 - x_2) \\
m_3\frac{d^2 x_3}{dt^2} &= m_3g + k_3(x_2 - x_3)
\end{align*}
\sphinxAtStartPar
En condiciones de equilibrio:
\begin{align*}
(k_1 + k_2)x_1\;\;\;\;\;\;\;\;\; - k_2x_2 \;\;\;\;\;\;\;\;\;\;\,&=  m_1g\\
- k_2x_1 + (k_2 + k_3)x_2 - k_3x_3  &= m_2g\\
- k_3x_2 + k_3x_3 &= m_3g
\end{align*}
\sphinxAtStartPar
En el ejemplo anterior, derivamos un sistema de ecuaciones lineales con 3 incognitas el cual podemos resolver con técnicas analíticas.

\sphinxAtStartPar
Sin embargo, si el sistema es más grande, como por ejemplo un reticulado de vigas:

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=300\sphinxpxdimen]{{beam_lattice}.png}\hspace*{\fill}}

\sphinxAtStartPar
Tenemos un sistema de ecuaciones con un gran número de incognitas y debemos recurrir a métodos más eficientes para poder resolverlos.

\sphinxAtStartPar
Este es el enfoque que utilizan los software de modelación computacional, tales como: el método de elementos finitos (FEM), métodos de los momentos (MoM), o volúmenes finitos (VEM).

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=600\sphinxpxdimen]{{fem_beam_lattice}.png}\hspace*{\fill}}


\subsection{Definición general}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:definicion-general}}
\sphinxAtStartPar
Decimos que una ecuación es lineal cuando:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Todas sus incognitas están \sphinxstylestrong{únicamente} separadas por sumas o restas

\item {} 
\sphinxAtStartPar
El exponente de cada incognita es \(1\).

\end{enumerate}

\sphinxAtStartPar
Por ejemplo,
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(3x_1 + 4x_2 - 3 = -5x_3\) (lineal)

\item {} 
\sphinxAtStartPar
\(\frac{-3x_1 + x_2}{x_3} = 2\) (no es lineal,  pero podemos la podemos transformar en una ecuación lineal: \$\( -3x_1 + x_2 -2x_3 = 0 )\)\$

\item {} 
\sphinxAtStartPar
\(x_1 x_2 + x_3 = 5\) (no lineal)

\item {} 
\sphinxAtStartPar
\(x_1 + 3x_2 + x_3^4 = 3\) (no lineal)

\end{itemize}
\begin{quote}

\sphinxAtStartPar
Un sistema de ecuaciones lineales esta compuesto por más de una ecuación lineal, tal como en el ejemplo de las personas conectadas por cuerdas elásticas
\end{quote}
\begin{align*}
(k_1 + k_2)x_1\;\;\;\;\;\;\;\;\; - k_2x_2 \;\;\;\;\;\;\;\;\;\;\,&=  m_1g\\
- k_2x_1 + (k_2 + k_3)x_2 - k_3x_3  &= m_2g\\
- k_3x_2 + k_3x_3 &= m_3g
\end{align*}

\subsection{Representación matricial}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:representacion-matricial}}
\sphinxAtStartPar
Para resolver sistemas de ecuaciones lineal se utiliza la representación matricial. Esto permite la implementación computacional de los algoritmos.

\sphinxAtStartPar
Por ejemplo, consideremos una ecuación lineal en su forma general:
\begin{eqnarray*}
\begin{array}{rcrcccccrcc}
a_{1,1} x_1 &+& a_{1,2} x_2 &+& {\ldots}& +& a_{1,n-1} x_{n-1} &+&a_{1,n} x_n &=& y_1,\\
a_{2,1} x_1 &+& a_{2,2} x_2 &+&{\ldots}& +& a_{2,n-1} x_{n-1} &+& a_{2,n} x_n &=& y_2, \\
&&&&{\ldots} &&{\ldots}&&&& \\
a_{m-1,1}x_1 &+& a_{m-1,2}x_2&+ &{\ldots}& +& a_{m-1,n-1} x_{n-1} &+& a_{m-1,n} x_n &=& y_{m-1},\\
a_{m,1} x_1 &+& a_{m,2}x_2 &+ &{\ldots}& +& a_{m,n-1} x_{n-1} &+& a_{m,n} x_n &=& y_{m}.
\end{array}
\end{eqnarray*}
\sphinxAtStartPar
donde \(a_{i,j}\) y \(y_i\) son números reales.

\sphinxAtStartPar
La forma matricial de esta ecuación tiene la siguiente forma:
\begin{equation*}
\begin{split}\begin{bmatrix}
a_{1,1} & a_{1,2} & ... & a_{1,n}\\
a_{2,1} & a_{2,2} & ... & a_{2,n}\\
... & ... & ... & ... \\
a_{m,1} & a_{m,2} & ... & a_{m,n}
\end{bmatrix}\left[\begin{array}{c} x_1 \\x_2 \\ ... \\x_n \end{array}\right] =
\left[\begin{array}{c} y_1 \\y_2 \\ ... \\y_m \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
O, similarmente,
\begin{equation*}
\begin{split}Ax = y,\end{split}
\end{equation*}
\sphinxAtStartPar
donde:
\$\(A = \begin{bmatrix}
a_{1,1} & a_{1,2} & ... & a_{1,n}\\
a_{2,1} & a_{2,2} & ... & a_{2,n}\\
... & ... & ... & ... \\
a_{m,1} & a_{m,2} & ... & a_{m,n}
\end{bmatrix},\;\;x= \left[\begin{array}{c} x_1 \\x_2 \\ ... \\x_n \end{array}\right],\;\;\ y = \left[\begin{array}{c} y_1 \\y_2 \\ ... \\y_m \end{array}\right]\)\$

\sphinxAtStartPar
De igual forma, el problema de las personas sujetas con elásticos,
\begin{align*}
(k_1 + k_2)x_1\;\;\;\;\;\;\;\;\; - k_2x_2 \;\;\;\;\;\;\;\;\;\;\,&=  m_1g\\
- k_2x_1 + (k_2 + k_3)x_2 - k_3x_3  &= m_2g\\
- k_3x_2 + k_3x_3 &= m_3g,
\end{align*}
\sphinxAtStartPar
se puede representar de forma matricial como:
\begin{equation*}
\begin{split}\begin{bmatrix}
k_1 + k_2 & -k_2 & 0 \\
-k_2 & k_2 + k_3 & -k_3\\
0 & -k_3 & k_3
\end{bmatrix}
\left[\begin{array}{c} x_1 \\x_2 \\ x_3 \end{array}\right] =
\left[\begin{array}{c} m_1g \\m_2g \\m_3g \end{array}\right]\end{split}
\end{equation*}

\subsection{Repaso de matrices}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:repaso-de-matrices}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Norma matricial.} Existen distintos tipos. La más conocida es la \sphinxstyleemphasis{p\sphinxhyphen{}norma}:
\begin{equation*}
\begin{split}\Vert M \Vert_{p} = \sqrt[p]{(\sum_i^m \sum_j^n |a_{ij}|^p)}\end{split}
\end{equation*}
\sphinxAtStartPar
Para \(p = 2\), se llama \sphinxstyleemphasis{norma de Frobenius}

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Determinante.} Se denota como \(det(M)\), o \(|M|\). \sphinxstylestrong{Solo se aplica a matrices cuadradas}.

\sphinxAtStartPar
Por ejemplo, para una matriz \(2\times2\), el determinante es:
\begin{equation*}
\begin{split} |M| = \begin{vmatrix} a & b \\ 
                             c & d\\ 
            \end{vmatrix} = ad - bc,\end{split}
\end{equation*}
\sphinxAtStartPar
para una matrix \(3\times3\):

\end{enumerate}
\begin{equation*}
\begin{split}
\begin{eqnarray*}
|M| = \begin{vmatrix}
a & b & c \\
d & e & f \\
g & h & i \\
\end{vmatrix} & = & a\begin{vmatrix}
\Box &\Box  &\Box  \\
\Box & e & f \\
\Box & h & i \\
\end{vmatrix} - b\begin{vmatrix}
\Box &\Box  &\Box  \\
d & \Box & f \\
g & \Box & i \\
\end{vmatrix}+c\begin{vmatrix}
\Box &\Box  &\Box  \\
d & e & \Box \\
g & h & \Box \\
\end{vmatrix} \\
&&\\
& = & a\begin{vmatrix}
e & f \\
h & i \\
\end{vmatrix} - b\begin{vmatrix}
d & f \\
g & i \\
\end{vmatrix}+c\begin{vmatrix}
d & e \\
g & h \\
\end{vmatrix} \\ 
&&\\
& = & aei - afh + bfg - bdi + cdh - ceg 
\end{eqnarray*}\end{split}
\end{equation*}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Matriz identidad (\(I\)).} es una matriz cuadarada con \(1\) en la diagonal, y \(0\) en el resto de los elementos:
\$\(I = \begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1 \\
\end{bmatrix}\)\$

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Matriz inversa.} Definimos la matriz inversa de \(M\) como: \(M^{-1}\).
\begin{itemize}
\item {} 
\sphinxAtStartPar
Solo existe para matrices cuadradas.

\item {} 
\sphinxAtStartPar
El producto de la matriz inversa por su diagonal es igual a la matriz identidad \(M\cdot M^{-1} = I\)

\item {} 
\sphinxAtStartPar
Para una matriz \(2\times2\), la matriz inversa está definida por:

\end{itemize}
\begin{equation*}
\begin{split}
M^{-1} = \begin{bmatrix}
a & b \\
c & d\\
\end{bmatrix}^{-1} = \frac{1}{|M|}\begin{bmatrix}
d & -b \\
-c & a\\
\end{bmatrix}\end{split}
\end{equation*}
\end{enumerate}
\begin{quote}

\sphinxAtStartPar
La solución analítica para determinar la matriz inversa se vuelve mas complicada a medida que aumentan las dimensiones de la matriz.
\end{quote}


\subsection{Representación en python}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:representacion-en-python}}
\sphinxAtStartPar
Para representar sistemas de ecuciones lineales en python utilizamos variables del tipo \sphinxstyleemphasis{numyp array} de la libreria \sphinxcode{\sphinxupquote{numpy}}.

\sphinxAtStartPar
Por ejemplo, para representar el sistema:
\begin{eqnarray*}
3x_1 + 1x_2 - 5x_3 &=& 2 \\
-2x_1 - 2x_2 + 5x_3 &=& 5 \\
8x_1 + 3x_2  &=& -3 \\
\end{eqnarray*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{3}\PYG{p}{,}  \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}  \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[} \PYG{l+m+mi}{8}\PYG{p}{,}  \PYG{l+m+mi}{3}\PYG{p}{,}  \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{y:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
A:
 [[ 3  1 \PYGZhy{}5]
 [\PYGZhy{}2 \PYGZhy{}2  5]
 [ 8  3  3]]

y:
 [[ 2]
 [ 5]
 [\PYGZhy{}3]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
La librería \sphinxcode{\sphinxupquote{linalg}} de \sphinxcode{\sphinxupquote{numpy}} tiene funciones predefinidas para calcular la norma, determinante y matriz inversa.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{numpy}\PYG{n+nn}{.}\PYG{n+nn}{linalg} \PYG{k+kn}{import} \PYG{n}{norm}\PYG{p}{,} \PYG{n}{det}\PYG{p}{,} \PYG{n}{inv}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{norm(A) = }\PYG{l+s+si}{\PYGZpc{}.4f}\PYG{l+s+s1}{ (Frobenius por defecto)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{\PYGZpc{}} \PYG{n}{norm}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{det(A) = }\PYG{l+s+si}{\PYGZpc{}.4f}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{det}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{inv(A):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{inv}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
norm(A) = 12.2474 (Frobenius por defecto)
det(A) = \PYGZhy{}67.0000
inv(A):
 [[ 0.31343284  0.26865672  0.07462687]
 [\PYGZhy{}0.68656716 \PYGZhy{}0.73134328  0.07462687]
 [\PYGZhy{}0.14925373  0.01492537  0.05970149]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} comprobamos la identidad A*A\PYGZca{}\PYGZhy{}1 = I}
\PYG{c+c1}{\PYGZsh{} usamos numpy.dot() para multiplicar matrices}
\PYG{n}{A}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{inv}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[ 1.00000000e+00, \PYGZhy{}5.20417043e\PYGZhy{}18,  3.46944695e\PYGZhy{}17],
       [ 0.00000000e+00,  1.00000000e+00,  2.08166817e\PYGZhy{}17],
       [ 2.22044605e\PYGZhy{}16,  9.19403442e\PYGZhy{}17,  1.00000000e+00]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Para la matriz identidad utilizamos la función \sphinxcode{\sphinxupquote{eye}} de la libreria \sphinxcode{\sphinxupquote{numpy}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Caracterización de sistemas de ecuaciones lineales}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:caracterizacion-de-sistemas-de-ecuaciones-lineales}}
\sphinxAtStartPar
\sphinxstyleemphasis{Un sistema de ecuaciones lineales tiene solución única, si y solo si el número de incognitas es igual al número de \sphinxstylestrong{ecuaciones linealmente independientes} en el sistema}

\sphinxAtStartPar
Por ejemplo, el siguiente sistema de ecuaciones lineales:
\begin{eqnarray*}
3x_1 + 1x_2 - 5x_3 &=& 2 \\
-2x_1 - 2x_2 + 5x_3 &=& 5 \\
4x_1 -5x_3  &=& 9 \\
\end{eqnarray*}
\sphinxAtStartPar
No tiene solución única, ya que: \((\mathrm{ec.~}3) = 2\times(\mathrm{ec.~}1) + (\mathrm{ec.~}2)\)

\sphinxAtStartPar
Definimos el rango de la matriz \(\mathrm{rank}(A)\), como el número de filas (o columnas) linealmente independenientes.

\sphinxAtStartPar
En python, \(\mathrm{rank}(A)\) está dado por la función \sphinxcode{\sphinxupquote{matrix\_rank}} de la librería \sphinxcode{\sphinxupquote{numpy.linalg}}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{numpy}\PYG{n+nn}{.}\PYG{n+nn}{linalg} \PYG{k+kn}{import} \PYG{n}{matrix\PYGZus{}rank}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{3}\PYG{p}{,}  \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}  \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[} \PYG{l+m+mi}{4}\PYG{p}{,}  \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{matrix\PYGZus{}rank}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Consideremos la matrix aumentada \([A|y]\)  como:
\begin{equation*}
\begin{split}[A|y] = \begin{bmatrix}
a_{1,1} & a_{1,2} & ... & a_{1,n} & y_1\\
a_{2,1} & a_{2,2} & ... & a_{2,n} & y_2\\
... & ... & ... & ... & ...\\
a_{m,1} & a_{m,2} & ... & a_{m,n} & y_n
\end{bmatrix}\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(A\) es una matriz \(m\times n\). Es decir, \(m\) ecuaciones y \(n\) incognitas.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{El sistema tiene solución única} si \(\mathrm{rank}\left([A|y]\right) = \mathrm{rank}\left(A\right)\), y \(\mathrm{rank}\left(A\right) = n\)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{El sistema tiene infinitas soluciones} si \(\mathrm{rank}\left([A|y]\right) = \mathrm{rank}\left(A\right)\), y \(\mathrm{rank}\left(A\right) < n\)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{El no tiene soluciones} si \(\mathrm{rank}\left([A|y]\right) = \mathrm{rank}\left(A\right) + 1\)

\end{itemize}

\sphinxAtStartPar
En el caso del ejemplo anterior:
\begin{eqnarray*}
3x_1 + 1x_2 - 5x_3 &=& 2 \\
-2x_1 - 2x_2 + 5x_3 &=& 5 \\
4x_1 -5x_3  &=& 9 \\
\end{eqnarray*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Ay\PYGZus{}aug} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{,}\PYG{n}{axis} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[A|y] =}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Ay\PYGZus{}aug}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rank(A|b) =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{matrix\PYGZus{}rank}\PYG{p}{(}\PYG{n}{Ay\PYGZus{}aug}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rank(A) =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{matrix\PYGZus{}rank}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Número de incognitas, n =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[A|y] =
 [[ 3  1 \PYGZhy{}5  2]
 [\PYGZhy{}2 \PYGZhy{}2  5  5]
 [ 4  0 \PYGZhy{}5  9]]


rank(A|b) = 2
rank(A) = 2
Número de incognitas, n = 3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{align*}
\mathrm{rank}\left([A|y]\right) &= \mathrm{rank}\left(A\right) \\
\mathrm{rank}\left(A\right) &\lt n
\end{align*}\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{El sistema tiene múltiples soluciones}
\end{quote}

\sphinxAtStartPar
\sphinxstyleemphasis{Si \(\mathrm{det}(A) = 0\),  decimos que \sphinxstylestrong{la matriz es singular} y, por lo tanto, no es invertible.}

\sphinxAtStartPar
Por ejemplo, la matriz:
\begin{equation*}
\begin{split}P = \begin{bmatrix}
1 & 2 & -1 \\
2 & 3 &  0 \\
1 & 1 &  1 \\
\end{bmatrix},\end{split}
\end{equation*}
\sphinxAtStartPar
es singular.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{P} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{det(P) = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{det}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
det(P) =  0.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
y, por lo tanto, no es invertible:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{inv(P) = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{inv}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{LinAlgError}\PYG{g+gWhitespace}{                               }Traceback (most recent call last)
\PYG{o}{/}\PYG{n}{tmp}\PYG{o}{/}\PYG{n}{ipykernel\PYGZus{}242}\PYG{o}{/}\PYG{l+m+mf}{453559162.}\PYG{n}{py} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{inv(P) = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{inv}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nn}{\PYGZti{}/programs/miniconda3/lib/python3.9/site\PYGZhy{}packages/numpy/core/overrides.py} in \PYG{n+ni}{inv}\PYG{n+nt}{(*args, **kwargs)}

\PYG{n+nn}{\PYGZti{}/programs/miniconda3/lib/python3.9/site\PYGZhy{}packages/numpy/linalg/linalg.py} in \PYG{n+ni}{inv}\PYG{n+nt}{(a)}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{550}     \PYG{n}{signature} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D\PYGZhy{}\PYGZgt{}D}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{n}{isComplexType}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)} \PYG{k}{else} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d\PYGZhy{}\PYGZgt{}d}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{551}     \PYG{n}{extobj} \PYG{o}{=} \PYG{n}{get\PYGZus{}linalg\PYGZus{}error\PYGZus{}extobj}\PYG{p}{(}\PYG{n}{\PYGZus{}raise\PYGZus{}linalgerror\PYGZus{}singular}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{552}     \PYG{n}{ainv} \PYG{o}{=} \PYG{n}{\PYGZus{}umath\PYGZus{}linalg}\PYG{o}{.}\PYG{n}{inv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{signature}\PYG{o}{=}\PYG{n}{signature}\PYG{p}{,} \PYG{n}{extobj}\PYG{o}{=}\PYG{n}{extobj}\PYG{p}{)}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{553}     \PYG{k}{return} \PYG{n}{wrap}\PYG{p}{(}\PYG{n}{ainv}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{result\PYGZus{}t}\PYG{p}{,} \PYG{n}{copy}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{554} 

\PYG{n+nn}{\PYGZti{}/programs/miniconda3/lib/python3.9/site\PYGZhy{}packages/numpy/linalg/linalg.py} in \PYG{n+ni}{\PYGZus{}raise\PYGZus{}linalgerror\PYGZus{}singular}\PYG{n+nt}{(err, flag)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{87} 
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{88} \PYG{k}{def} \PYG{n+nf}{\PYGZus{}raise\PYGZus{}linalgerror\PYGZus{}singular}\PYG{p}{(}\PYG{n}{err}\PYG{p}{,} \PYG{n}{flag}\PYG{p}{)}\PYG{p}{:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{89}     \PYG{k}{raise} \PYG{n}{LinAlgError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Singular matrix}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{90} 
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{91} \PYG{k}{def} \PYG{n+nf}{\PYGZus{}raise\PYGZus{}linalgerror\PYGZus{}nonposdef}\PYG{p}{(}\PYG{n}{err}\PYG{p}{,} \PYG{n}{flag}\PYG{p}{)}\PYG{p}{:}

\PYG{n+ne}{LinAlgError}: Singular matrix
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstyleemphasis{Decimos que una matriz \(A\) está \sphinxstylestrong{mal condicionada}, si \(\mathrm{det}(A) \approx 0\).}

\sphinxAtStartPar
Si bien las matrices mal condicionadas tienen inversa, son numericamente problemáticas, ya que pueden inducir errores de redondeo, \sphinxstyleemphasis{overflow} o \sphinxstyleemphasis{underflow} como resultado de la división por un número muy pequeño

\sphinxAtStartPar
Para determinar si una matriz está mal condicionada utilizamos el \sphinxstylestrong{número de condición}, definido como:
\begin{equation*}
\begin{split}\mathrm{Cond}(A) = \|A\|\cdot\|A^{-1}\|\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstyleemphasis{Matrices mal condicionadas están caracterizadas por “\(\mathrm{Cond}(A)\)” altos}

\sphinxAtStartPar
En python, \(\mathrm{Cond}(A)\) está dado por la función \sphinxcode{\sphinxupquote{cond}} de la librería \sphinxcode{\sphinxupquote{numpy.linalg}}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{numpy}\PYG{n+nn}{.}\PYG{n+nn}{linalg} \PYG{k+kn}{import} \PYG{n}{cond}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cond(P) = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{cond}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Cond(P) =  3.757434988222266e+16
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{quote}

\sphinxAtStartPar
\(\mathrm{det}(A)= 0\), no necesariamente significa que el sistema no tiene solución
\end{quote}

\sphinxAtStartPar
Por ejemplo, en el ejemplo anterior
\begin{eqnarray*}
3x_1 + 1x_2 - 5x_3 &=& 2 \\
-2x_1 - 2x_2 + 5x_3 &=& 5 \\
4x_1 -5x_3  &=& 9 \\
\end{eqnarray*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{A}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{det(A) = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{det}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
A
 [[ 3  1 \PYGZhy{}5]
 [\PYGZhy{}2 \PYGZhy{}2  5]
 [ 4  0 \PYGZhy{}5]]


det(A) =  0.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Sin embargo, como habíamos determinado, el sistema tiene múltiples soluciones.


\section{Métodos de solución directos}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:metodos-de-solucion-directos}}

\subsection{Eliminación de Gauss}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:eliminacion-de-gauss}}
\sphinxAtStartPar
Es un algoritmo para resolver sistemas ecuaciones lineales basado en convertir la matriz \(A\) en una matriz \sphinxstylestrong{triangular superior}. El sistema toma la forma:
\begin{equation*}
\begin{split}\begin{bmatrix}
a_{1,1} & a_{1,2} & a_{1,3} & a_{1,4}\\
0 & a_{2,2}' & a_{2,3}' & a_{2,4}'\\
0 & 0 & a_{3,3}' & a_{3,4}' \\
0 & 0 & 0 & a_{4,4}'
\end{bmatrix}\left[\begin{array}{c} x_1 \\x_2 \\ x_3 \\x_4 \end{array}\right] =
\left[\begin{array}{c} y_1 \\y_2' \\ y_3' \\y_4' \end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
Esta ecuación puede resolverse fácilmente, comenzando por \(x_4 = y_4'/a_{4,4}'\), luego continuamos con \(x_3 = \frac{y_3' - a_{3,4}x_4}{ a_{3,4}}\), y así sucesivamente hasta llegar a \(x_1\). En otras palabras, utilizamos \sphinxstylestrong{sustitución hacia atrás}, resolviendo el sistema desde abajo hacia arriba.

\sphinxAtStartPar
Si \(A\) es una matriz \sphinxstylestrong{triangular inferior}, resolveríamos el problema de arriba hacia abajo utilizando \sphinxstylestrong{sustitución hacia adelante.}

\sphinxAtStartPar
La mejor forma de entender el método de eliminación Gauseana es con un ejemplo:
\begin{eqnarray*}
4x_1 + 3x_2 - 5x_3 &=& 2 \\
-2x_1 - 4x_2 + 5x_3 &=& 5 \\
8x_1 + 8x_2  &=& -3 \\
\end{eqnarray*}
\sphinxAtStartPar
Paso 1: Transformamos el sistema de ecuaciones en su forma matricial \(Ax=y\).
\begin{equation*}
\begin{split}
\begin{bmatrix}
4 & 3 & -5\\
-2 & -4 & 5\\
8 & 8 & 0\\
\end{bmatrix}\left[\begin{array}{c} x_1 \\x_2 \\x_3 \end{array}\right] =
\left[\begin{array}{c} 2 \\5 \\-3\end{array}\right]\end{split}
\end{equation*}
\sphinxAtStartPar
Paso 2: Determinar la matriz aumentada {[}A, y{]}
\begin{equation*}
\begin{split}
[A, y]  = \begin{bmatrix}
4 & 3 & -5 & 2\\
-2 & -4 & 5 & 5\\
8 & 8 & 0 & -3\\
\end{bmatrix}\end{split}
\end{equation*}


\sphinxAtStartPar
Paso 3: Deteriminamos la matriz triangular superior utilizando pivoteo parcial y eliminación.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Comenzando por la primera columna. Primero, permutamos las filas de manera que el coeficiente con mayor valor absoluto quede en la primera fila:

\end{itemize}
\begin{equation*}
\begin{split}
[A, y]  = \begin{bmatrix}
8 & 8 & 0 & -3\\
4 & 3 & -5 & 2\\
-2 & -4 & 5 & 5\\
\end{bmatrix}\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
Luego, eliminamos los otros coeficientes de la primera columna, comenzando por el segundo. Multiplicamos la primera fila por \(1/2\) y la restamos a la segunda fila:

\end{itemize}
\begin{equation*}
\begin{split}
[A, y]  = \begin{bmatrix}
8 & 8 & 0 & -3\\
0 & -1 & -5 & 3.5\\
-2 & -4 & 5 & 5\\
\end{bmatrix}\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
Después, multiplicamos la primera fila por \(- 1/4\) y la restamos a la tercera fila:

\end{itemize}
\begin{equation*}
\begin{split}
[A, y]  = \begin{bmatrix}
8 & 8 & 0 & -3\\
0 & -1 & -5 & 3.5\\
0 & -2 & 5 & 4.25\\
\end{bmatrix}\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
Repetimos el proceso con la segunda columna. Primero, permutamos las filas:

\end{itemize}
\begin{equation*}
\begin{split}
[A, y]  = \begin{bmatrix}
8 & 8 & 0 & -3\\
0 & -2 & 5 & 4.25\\
0 & -1 & -5 & 3.5\\
\end{bmatrix}\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
Luego, eliminamos el coeficiente inferior.  Multiplicamos por la segunda fila por \(1/2\) y restamos a la tercera fila:

\end{itemize}
\begin{equation*}
\begin{split}
[A, y]  = \begin{bmatrix}
8 & 8 & 0 & -3\\
0 & -2 & 5 & 4.25\\
0 & 0 & -7.5 & 1.375\\
\end{bmatrix}\end{split}
\end{equation*}
\sphinxAtStartPar
Paso 4. Realizamos sustitución hacia atras.
\begin{align*}
x_3 &= \frac{-1.375}{7.5}=-0.183 \\
x_2 &= \frac{4.25 - (-2)x_3}{5} = -2.583 \\
x_1 &= \frac{-3 - 8x_2 + 0x_3}{8} = 2.208
\end{align*}\begin{quote}

\sphinxAtStartPar
El método de eliminación Gaussiana es de complejidad \(O(N^3)\)
\end{quote}


\subsection{Factorización LU}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:factorizacion-lu}}
\sphinxAtStartPar
Es posible demostrar que cualquier matriz cuadrada \(A\) puede ser expresada como el producto de una matriz triangular inferor \(L\), y una matriz triangular superior \(U\).
\begin{equation*}
\begin{split}A = LU\end{split}
\end{equation*}
\sphinxAtStartPar
El proceso para obtener \(L\) y \(U\) es conocido como \sphinxstyleemphasis{descomposición} o \sphinxstyleemphasis{factorización} LU. \sphinxstylestrong{Es el método de solución de ecuaciones lineales más confiable y utilizado.}

\sphinxAtStartPar
El tipo de factorización LU no es única, ya que existen múltiples formas de representar \(L\) y \(U\) para un \(A\) dado. Así, definimos tres tipos de factorizaciones comúnmente utilizadas:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Nombre
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Condiciones
\\
\hline
\sphinxAtStartPar
Doolittle
&
\sphinxAtStartPar
\(L_{ii} = 1\), \(i = 1, 2,... \), \(n\)
\\
\hline
\sphinxAtStartPar
Crout
&
\sphinxAtStartPar
\(U_{ii} = 1\), \(i = 1, 2,... \), \(n\)
\\
\hline
\sphinxAtStartPar
Choleski
&
\sphinxAtStartPar
\(L = U^T\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Una vez ejecutada la factorización, resolvemos el sistema \(Ax = y\).

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=500\sphinxpxdimen]{{LU_schematic}.png}\hspace*{\fill}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Primero resolvemos el sistema \(Ld = y\), por sustitución hacia adelante.

\item {} 
\sphinxAtStartPar
Luego, resolvemos el sistema \(Ux = d\), por sustitución hacia atrás.

\end{itemize}
\begin{quote}

\sphinxAtStartPar
A diferencia del método de eliminación de Gauss, la factorizacion LU no depende del vector \(y\). Por lo tanto, es conveniente para resolver el sistema \(Ax=y\), con múltiples valores de \(y\).
\end{quote}
\begin{quote}

\sphinxAtStartPar
Debido a que la factorización LU está basada en eliminación de Gauss, el orden de complejidad es \(O(N^3)\).
\end{quote}

\sphinxAtStartPar
Existen diversos métodos para obtener las matrices \(L\) y \(U\). Uno de ellos es mediante eliminación Gaussiana.

\sphinxAtStartPar
Como mostramos anteriormente, el método de eliminación de Gauss permite determinar una matriz triangular superior. La matriz triangular inferior, aunque no se mostró de forma explicita esta conformada por “\(1\)” en la diagonal, y los múltiplos utilizados para eliminar los elementos de las columnas.

\sphinxAtStartPar
En general, se puede demostrar que para una matriz \(A\), se cumple la siguiente relación:
\begin{equation*}
\begin{split}PA = LU\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(P\) es la matriz de permitaciones.

\sphinxAtStartPar
Por ejemplo, en el ejercicio anterior:
\begin{eqnarray*}
4x_1 + 3x_2 - 5x_3 &=& 2 \\
-2x_1 - 4x_2 + 5x_3 &=& 5 \\
8x_1 + 8x_2  &=& -3 \\
\end{eqnarray*}
\sphinxAtStartPar
Tenemos:
\$\(
L  = \begin{bmatrix}
1 & 0 & 0 \\
-0.25 & 1 & 0 \\
0.5 & 0.5 & 1 \\
\end{bmatrix};
U  = \begin{bmatrix}
8 & 8 & 0 \\
0 & -2 & 5 \\
0 & 0 & -7.5 \\
\end{bmatrix}; 
P  = \begin{bmatrix}
0 & 0 & 1 \\
0 & 1 & 0 \\
1 & 0 & 0 \\
\end{bmatrix}\)\$

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{4}\PYG{p}{,}  \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,}  \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} 
              \PYG{p}{[} \PYG{l+m+mi}{8}\PYG{p}{,}  \PYG{l+m+mi}{8}\PYG{p}{,}  \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{L} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}    \PYG{l+m+mi}{1}\PYG{p}{,}   \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{p}{,}   \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[}  \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{8}\PYG{p}{,}  \PYG{l+m+mi}{8}\PYG{p}{,}   \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}   \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[} \PYG{l+m+mi}{0}\PYG{p}{,}  \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.5}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{P} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P*A =}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{P}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L*U =}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,}\PYG{n}{U}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
P*A =
 [[ 8  8  0]
 [\PYGZhy{}2 \PYGZhy{}4  5]
 [ 4  3 \PYGZhy{}5]]


L*U =
 [[ 8.  8.  0.]
 [\PYGZhy{}2. \PYGZhy{}4.  5.]
 [ 4.  3. \PYGZhy{}5.]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Métodos iterativos}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:metodos-iterativos}}
\sphinxAtStartPar
Los métodos iterativos están basados en una serie repetitiva de operaciones, comenzando por un valor inicial. A diferencia de los métodos directos, el número de operaciones está condicionado por la convergencia y el valor inicial escogido.

\sphinxAtStartPar
Las ventajas de los métodos iterativos es que tienen un orden de complejidad menor que los métodos directos, y no requieren gran capacidad de memoria (recordemos que factorización LU requiere almacenar las matrices L, U y P)

\sphinxAtStartPar
La gran desventaja radica en la convergencia de los algoritmos. Una condición suficiente, pero no necesaria es que la matriz \(A\) debe ser \sphinxstylestrong{diagonal dominante}, es decir, los elementos de la diagonal, \(a_{i,i}\), deben satisfacer:
\$\(|a_{i,i}| \geq \sum_{j\neq i} |a_{i,j}|\)\$

\sphinxAtStartPar
Estos métodos se utilizan, generalmente, en simulaciones con elementos finitos (FEM), o volúmenes finitos (VEM).


\subsection{Gauss\sphinxhyphen{}Seidel}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:gauss-seidel}}
\sphinxAtStartPar
El algoritmo se puede resumir en los siguientes pasos:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Asumimos un valor inicial para \(x_2^{(0)}, x_3^{(0)}, \cdots, x_n^{(0)}\) (con excepción de \(x_1^{(0)}\)).

\item {} 
\sphinxAtStartPar
Calculamos un nuevo valor para \(x_1^{(1)}\) mediante:
\$\(
x_1^{(1)} = \frac{1}{a_{1,1}}\Big[y_1 - \sum_{j \ne 1}^{n}{a_{1,j}x_j^{(0)}} \Big]
\)\$

\item {} 
\sphinxAtStartPar
Utilizando el nuevo valor \(x_1^{(1)}\) y el resto de \(x^{(0)}\) (con excepción de \(x_2^{(0)}\)), determinamos \(x_2^{(1)}\).
\$\(
x_2^{(1)} = \frac{1}{a_{2,2}}\Big[y_2 - \sum_{j \ne 1,2}^{n}{a_{2,j}x_j^{(0)}}  - {a_{2,1}x_1^{(1)}}\Big]
\)\$

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Repetimos el paso 3 hasta completar todos los elementos del vector \(x\).

\item {} 
\sphinxAtStartPar
Continuamos con la iteración hasta que el valor de \(x\) converge dentro de una tolerancia \(\varepsilon\), definida por:

\end{enumerate}
\begin{equation*}
\begin{split}\| x^{(i)} - x^{(i-1)}\| \lt \varepsilon\end{split}
\end{equation*}
\sphinxAtStartPar
Por ejemplo, resolvamos el siguiente sistema de ecuaciones con el métodod de Gauss\sphinxhyphen{}Seidel:
\begin{eqnarray*}
8x_1 + 3x_2 - 3x_3 &=& 14 \\
-2x_1 - 8x_2 + 5x_3 &=& 5 \\
3x_1 + 5x_2 + 10x_3 & =& -8 \\
\end{eqnarray*}
\sphinxAtStartPar
Primero, verificamos que la matriz es diagonal dominante:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[} \PYG{l+m+mf}{8.}\PYG{p}{,}  \PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.}\PYG{p}{]}\PYG{p}{,} 
     \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.}\PYG{p}{,}  \PYG{l+m+mf}{5.}\PYG{p}{]}\PYG{p}{,} 
      \PYG{p}{[}\PYG{l+m+mf}{3.}\PYG{p}{,}  \PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{l+m+mf}{10.}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} coeficientes de la diagonal}
\PYG{n}{diagA} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{diag}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)} 
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{diag(A) = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{diagA}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} suma de los elementos sin la diagonal}
\PYG{n}{off\PYGZus{}diagA} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{diagA}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off\PYGZus{}diag(A) =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{off\PYGZus{}diagA}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
diag(A) =  [ 8.  8. 10.]
off\PYGZus{}diag(A) = [6. 7. 8.]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{np}\PYG{o}{.}\PYG{n}{all}\PYG{p}{(}\PYG{n}{diagA} \PYG{o}{\PYGZgt{}} \PYG{n}{off\PYGZus{}diagA}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{la matriz es diagonal dominante}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{la matriz no es diagonal dominante}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
la matriz es diagonal dominante
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gauss\PYGZus{}seidel}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    
    \PYG{n}{epsilon} \PYG{o}{=} \PYG{l+m+mf}{0.001} \PYG{c+c1}{\PYGZsh{} tolerancia}
    \PYG{n}{converged} \PYG{o}{=} \PYG{k+kc}{False} \PYG{c+c1}{\PYGZsh{} verificar convergencia}
    
    \PYG{c+c1}{\PYGZsh{} guardamos el valor inicial}
    \PYG{n}{x\PYGZus{}old} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}              \PYG{c+c1}{\PYGZsh{} xi = yi}
            \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n}{j}\PYG{p}{:}           \PYG{c+c1}{\PYGZsh{} saltamos i = j}
                    \PYG{k}{continue}
                \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} xi =  yi \PYGZhy{} sum(aij*xj)}
            \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{/}\PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}      \PYG{c+c1}{\PYGZsh{} xi = (yi \PYGZhy{} sum(aij*xj))/aii}
    
        \PYG{c+c1}{\PYGZsh{} comparamos el error con la tolerancia}
        \PYG{n}{dx} \PYG{o}{=} \PYG{n}{norm}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{x\PYGZus{}old}\PYG{p}{)}
        
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{iter =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{; x =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{dx} \PYG{o}{\PYGZlt{}} \PYG{n}{epsilon}\PYG{p}{:}
            \PYG{n}{converged} \PYG{o}{=} \PYG{k+kc}{True}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Converged!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{k}{break}
        
        \PYG{c+c1}{\PYGZsh{} guardamos el valor de x para la nueva iteracion}
        \PYG{n}{x\PYGZus{}old} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{converged}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{No converge, incrementar número de iteraciones}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{x}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[} \PYG{l+m+mf}{8.}\PYG{p}{,}  \PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.}\PYG{p}{]}\PYG{p}{,} 
     \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.}\PYG{p}{,}  \PYG{l+m+mf}{5.}\PYG{p}{]}\PYG{p}{,} 
      \PYG{p}{[}\PYG{l+m+mf}{3.}\PYG{p}{,}  \PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{l+m+mf}{10.}\PYG{p}{]}\PYG{p}{]}

\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{14.}\PYG{p}{,} \PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} valores iniciales}
\PYG{n}{gauss\PYGZus{}seidel}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
iter = 1 ; x = [ 1.75    \PYGZhy{}1.0625  \PYGZhy{}0.79375]
iter = 2 ; x = [ 1.85078125 \PYGZhy{}1.58378906 \PYGZhy{}0.56333984]
iter = 3 ; x = [ 2.13266846 \PYGZhy{}1.51025452 \PYGZhy{}0.68467328]
iter = 4 ; x = [ 2.05959296 \PYGZhy{}1.56781904 \PYGZhy{}0.63396837]
iter = 5 ; x = [ 2.100194   \PYGZhy{}1.54627873 \PYGZhy{}0.65691883]
iter = 6 ; x = [ 2.08350996 \PYGZhy{}1.55645176 \PYGZhy{}0.64682711]
iter = 7 ; x = [ 2.09110925 \PYGZhy{}1.55204425 \PYGZhy{}0.65131065]
iter = 8 ; x = [ 2.0877751  \PYGZhy{}1.55401293 \PYGZhy{}0.64932607]
iter = 9 ; x = [ 2.08925757 \PYGZhy{}1.55314318 \PYGZhy{}0.65020568]
iter = 10 ; x = [ 2.08860156 \PYGZhy{}1.55352894 \PYGZhy{}0.649816  ]
Converged!
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([ 2.08860156, \PYGZhy{}1.55352894, \PYGZhy{}0.649816  ])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Solución de sistemas de ecuaciones lineales con python}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:solucion-de-sistemas-de-ecuaciones-lineales-con-python}}
\sphinxAtStartPar
En python la forma más facil de resolver sistemas de ecuaciones lineal es mediante la función \sphinxcode{\sphinxupquote{solve}} de \sphinxcode{\sphinxupquote{numpy.linalg}}. Esta función utiliza factorización LU para resolver el sistema.

\sphinxAtStartPar
Por ejemplo, tomemos el ejemplo de las personas conectadas por elásticos:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Persona
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Masa (kg)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Constante del resorte (N/m)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Longitud incial del elástico
\\
\hline
\sphinxAtStartPar
primera
&
\sphinxAtStartPar
60
&
\sphinxAtStartPar
50
&
\sphinxAtStartPar
20
\\
\hline
\sphinxAtStartPar
segunda
&
\sphinxAtStartPar
70
&
\sphinxAtStartPar
100
&
\sphinxAtStartPar
20
\\
\hline
\sphinxAtStartPar
tercera
&
\sphinxAtStartPar
80
&
\sphinxAtStartPar
50
&
\sphinxAtStartPar
20
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Tenemos un sistema de la forma:
\begin{equation*}
\begin{split}
\begin{bmatrix}
150 & -100 & 0\\
-100 & 150 & -50\\
0 & -50 & 50\\
\end{bmatrix}\left[\begin{array}{c} x_1 \\x_2 \\x_3 \end{array}\right] =
\left[\begin{array}{c} 588.6 \\686.7 \\784.8\end{array}\right]\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{150}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{,}   \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} 
              \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{,}  \PYG{l+m+mi}{150}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{,} 
              \PYG{p}{[}   \PYG{l+m+mi}{0}\PYG{p}{,}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50}\PYG{p}{,}  \PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{588.6}\PYG{p}{,} \PYG{l+m+mf}{686.7}\PYG{p}{,} \PYG{l+m+mf}{784.8}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[41.202 55.917 71.613]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Notar que en este problema \(x_1\), \(x_2\) y \(x_3\) representan las posiciones relativas de las personas. Así la posición final está dada por:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Posición final de las personas: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x} \PYG{o}{+} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{60}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Posición final de las personas:  [ 61.202  95.917 131.613]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Mediante la librería \sphinxcode{\sphinxupquote{scipy}} podemos hacer factorización LU.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{linalg} \PYG{k+kn}{import} \PYG{n}{lu}

\PYG{n}{P}\PYG{p}{,} \PYG{n}{L}\PYG{p}{,} \PYG{n}{U} \PYG{o}{=} \PYG{n}{lu}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{P}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LU:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{L}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
P:
 [[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
L:
 [[ 1.          0.          0.        ]
 [\PYGZhy{}0.66666667  1.          0.        ]
 [ 0.         \PYGZhy{}0.6         1.        ]]
U:
 [[ 150.         \PYGZhy{}100.            0.        ]
 [   0.           83.33333333  \PYGZhy{}50.        ]
 [   0.            0.           20.        ]]
LU:
 [[ 150. \PYGZhy{}100.    0.]
 [\PYGZhy{}100.  150.  \PYGZhy{}50.]
 [   0.  \PYGZhy{}50.   50.]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Referencias}
\label{\detokenize{1.2-Algebra_lineal/1.2-Algebra_lineal:referencias}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Kong Q., Siauw T., Bayen A. M. \sphinxstylestrong{Chapter 14: Linear Algebra and Systems of Linear Equations} in \sphinxstyleemphasis{\sphinxhref{https://pythonnumericalmethods.berkeley.edu/notebooks/Index.html}{Python Programming and Numerical Methods – A Guide for Engineers and Scientists}}, 1st Ed., Academic Press, 2021

\item {} 
\sphinxAtStartPar
Chapra S., Canale R. \sphinxstylestrong{Parte tres: Ecuaciones algebraicas lineales} en \sphinxstyleemphasis{Métodos Numéricos para Ingenieros}, 6ta Ed., McGraw Hill, 2011

\end{itemize}







\renewcommand{\indexname}{Index}
\printindex
\end{document}