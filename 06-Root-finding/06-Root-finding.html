
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>6. Algoritmos de búsqueda de raíces &#8212; MEC301 - Métodos Numéricos</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/custom_edits.css?v=2756f859" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '06-Root-finding/06-Root-finding';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="7. Integración numérica" href="../07-Integracion/07-Integracion.html" />
    <link rel="prev" title="5. Series de Taylor" href="../05-Taylor-series/05-Taylor-series.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
  
    <p class="title logo__title">MEC301 - Métodos Numéricos</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Bienvenidos al curso
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Parte 1. Introducción a los métodos numéricos</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../01-Aspectos_generales/01-Aspectos_generales.html">1. Aspectos generales de programación y algoritmos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02-Algebra_lineal/02-Algebra_lineal.html">2. Algebra lineal y sistemas de ecuaciones lineales</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03-Ajuste_de_curvas/03-Ajuste_de_curvas.html">3. Ajuste de curvas por mínimos cuadrados</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04-Interpolacion/04-Interpolacion.html">4. Métodos de Interpolación</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Parte 2. Métodos numéricos basados en series de Taylor</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../05-Taylor-series/05-Taylor-series.html">5. Series de Taylor</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">6. Algoritmos de búsqueda de raíces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07-Integracion/07-Integracion.html">7. Integración numérica</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Parte 3. Métodos numéricos para ecuaciones diferenciales</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../08-Derivacion_numerica/08-Derivacion_numerica.html">8. Derivación numérica</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09-EDO_valor_inicial/09-EDO_valor_inicial.html">9. Problemas de valor inicial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10-EDO_condicion_de_borde/10-EDO_condicion_de_borde.html">10. Problema de valor en la frontera</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11-DiferenciasFinitas_EDP/11-DiferenciasFinitas_EDP.html">11. Diferencias finitas para ecuaciones diferenciales parciales</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://colab.research.google.com/github/PanxoPanza/metodos_numericos_mec301/blob/main/06-Root-finding/06-Root-finding.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Colab"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Colab logo" src="../_static/images/logo_colab.png">
  </span>
<span class="btn__text-container">Colab</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/06-Root-finding/06-Root-finding.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Algoritmos de búsqueda de raíces</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduccion">6.1. Introducción</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#busqueda-de-raices-para-una-funcion-escalar">6.2. Búsqueda de raíces para una función escalar</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodo-de-la-biseccion-intervalo-acotado">6.2.1. Método de la Bisección (intervalo acotado)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#criterio-de-convergencia">6.2.1.1. Criterio de convergencia</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodo-de-newton-raphson-intervalo-abierto">6.2.2. Método de Newton-Raphson (intervalo abierto)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#caso-f-x-no-es-analitica-metodo-de-la-secante">6.2.2.1. Caso <span class="math notranslate nohighlight">\(f'(x)\)</span> no es analítica (Método de la secante)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#problemas-de-convergencia">6.2.2.2. Problemas de convergencia</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#control-de-la-solucion">6.2.2.3. Control de la solución</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodos-combinados">6.2.3. Métodos combinados</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#raices-de-funcion-escalar-en-python">6.2.4. Raices de función escalar en python</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#busqueda-de-raices-para-funciones-vectoriales">6.3. Búsqueda de raíces para funciones vectoriales</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodos-de-busqueda-lineal">6.3.1. Métodos de búsqueda lineal</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodos-de-region-de-confianza">6.3.2. Métodos de región de confianza</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#raices-de-funcion-vectorial-en-python">6.3.3. Raíces de función vectorial en python</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#referencias">6.4. Referencias</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="algoritmos-de-busqueda-de-raices">
<h1><span class="section-number">6. </span>Algoritmos de búsqueda de raíces<a class="headerlink" href="#algoritmos-de-busqueda-de-raices" title="Link to this heading">#</a></h1>
<section id="introduccion">
<h2><span class="section-number">6.1. </span>Introducción<a class="headerlink" href="#introduccion" title="Link to this heading">#</a></h2>
<p>Consideremos el problema de caída de presión <span class="math notranslate nohighlight">\(\Delta P\)</span> al mover un fluído con densidad <span class="math notranslate nohighlight">\(\rho\)</span> y viscosidad cinemática <span class="math notranslate nohighlight">\(\nu\)</span>, a través de una tubería de largo <span class="math notranslate nohighlight">\(L\)</span>.</p>
<a class="reference internal image-reference" href="../_images/presure_drop.png"><img alt="../_images/presure_drop.png" class="align-center" src="../_images/presure_drop.png" style="width: 350px;" />
</a>
<p>Para un fluido que fluye a una velocidad <span class="math notranslate nohighlight">\(V\)</span>, la caída de presión está dada por:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\frac{\Delta P}{\rho g} =f_c \frac{L}{D}\frac{V^2}{2g}
\end{equation*}\]</div>
<p>donde <span class="math notranslate nohighlight">\(f\)</span> es el factor de fricción.</p>
<p>Para determinar <span class="math notranslate nohighlight">\(f_c\)</span> debemos resolver la ecuación de Colebrook:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\frac{1}{\sqrt{f_c}} = -2.0\log\left(\frac{\varepsilon/D}{3.7} + \frac{2.51}{\mathrm{Re}\sqrt{f_c}}\right)
\end{equation*}\]</div>
<p>donde <span class="math notranslate nohighlight">\(\mathrm{Re} = \frac{VD}{\nu}\)</span> es el número de Reynolds, y <span class="math notranslate nohighlight">\(\varepsilon/D\)</span> la rugosidad relativa.</p>
<p>Sin embargo, esta ecuación no se puede resolver analíticamente. ¿Como resolvemos esta ecuación?</p>
<p>Llamamos raíces de una función <span class="math notranslate nohighlight">\(f(x)\)</span> a los valores <span class="math notranslate nohighlight">\(x^*\)</span> tales que <span class="math notranslate nohighlight">\(f(x^*) = 0\)</span>.</p>
<p>Determinar <span class="math notranslate nohighlight">\(f_c\)</span> a partir de la ecuación de Colebrook es equivalente a encontrar las raíces de la función:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
f(x) = \frac{1}{\sqrt{x}} + 2.0\log\left(\frac{\varepsilon/D}{3.7} + \frac{2.51}{\mathrm{Re}\sqrt{x}}\right)
\end{equation*}\]</div>
<p>En esta unidad revisaremos los aspectos generales de los algoritmos para busqueda de raíces de una función.</p>
</section>
<section id="busqueda-de-raices-para-una-funcion-escalar">
<h2><span class="section-number">6.2. </span>Búsqueda de raíces para una función escalar<a class="headerlink" href="#busqueda-de-raices-para-una-funcion-escalar" title="Link to this heading">#</a></h2>
<p>Una función escalar es una función con una o más variables dependientes, que entrega un valor unidimencional.</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
f: x\in \mathbb{R}^n \rightarrow \mathbb{R}
\end{equation*}\]</div>
<p>Resolver una ecuación unidimiencional es equivalente a encontrar las raices de una función escalar con <strong>una variable dependiente.</strong></p>
<p>En otras palabras, dada una función <span class="math notranslate nohighlight">\(f(x)\)</span>, las raíces <span class="math notranslate nohighlight">\(x_0\)</span> están dadas por <span class="math notranslate nohighlight">\(f(x_0) = 0\)</span>.</p>
<p>Para una solución <span class="math notranslate nohighlight">\(x_0\)</span>, tal que <span class="math notranslate nohighlight">\(f(x_0) = 0\)</span>, podemos clasificar los métodos para resolver este problema en tres tipos:</p>
<ul class="simple">
<li><p><strong>Métodos de intervalo cerrado.</strong> buscan la raíz <span class="math notranslate nohighlight">\(x_0\)</span> iterando dentro un intervalo <span class="math notranslate nohighlight">\(x\in[a, b]\)</span> acotado.</p></li>
<li><p><strong>Métodos de intervalo abierto.</strong> buscan la raíz <span class="math notranslate nohighlight">\(x_0\)</span> iterando desde un valor inicial, sin acotar el intervalo de búsqueda.</p></li>
<li><p><strong>Métodos combinados.</strong> Combinan iteraciones con intervalo abierto y cerrado según convenga.</p></li>
</ul>
<p>En esta unidad veremos el método de la bisección (intervalo cerrado) y el método de Newton-Raphson (intervalo abierto).</p>
<section id="metodo-de-la-biseccion-intervalo-acotado">
<h3><span class="section-number">6.2.1. </span>Método de la Bisección (intervalo acotado)<a class="headerlink" href="#metodo-de-la-biseccion-intervalo-acotado" title="Link to this heading">#</a></h3>
<p>El método de la bisección es un método de intervalo acotado que se basa en el teorema del valor intermedio</p>
<blockquote>
<div><p><strong>Teorema del valor intermedio</strong> para una función <span class="math notranslate nohighlight">\(f(x)\)</span> continua en entre los puntos <span class="math notranslate nohighlight">\(a\)</span> y <span class="math notranslate nohighlight">\(b\)</span>, tal que <span class="math notranslate nohighlight">\(f(a)f(b) &lt; 0\)</span>, existe un valor <span class="math notranslate nohighlight">\(c\)</span>, <span class="math notranslate nohighlight">\(a&lt;c&lt;b\)</span>, tal que <span class="math notranslate nohighlight">\(f(c) = 0\)</span>.</p>
</div></blockquote>
<a class="reference internal image-reference" href="../_images/valor_intermedio.png"><img alt="../_images/valor_intermedio.png" class="align-center" src="../_images/valor_intermedio.png" style="width: 400px;" />
</a>
<p>Para un intervalo <span class="math notranslate nohighlight">\(x\in [a,b]\)</span>, tal que <span class="math notranslate nohighlight">\(f(a)f(b) &lt; 0\)</span>, el método de la bisección consiste en acotar el intervalo evaluando el punto medio <span class="math notranslate nohighlight">\(f(m)\)</span>, con <span class="math notranslate nohighlight">\(m = \frac{a+b}{2}\)</span>.</p>
<ul class="simple">
<li><p>Si <span class="math notranslate nohighlight">\(f(m)f(a) &lt; 0\)</span> el nuevo interfalo es <span class="math notranslate nohighlight">\(x\in [a,m]\)</span>, de lo contrario, <span class="math notranslate nohighlight">\(x\in [m, b]\)</span></p></li>
</ul>
<p>El algoritmo continua acotando el intervalo hasta encontrar la raíz de <span class="math notranslate nohighlight">\(f(x)\)</span>.</p>
<a class="reference internal image-reference" href="../_images/bisection.png"><img alt="../_images/bisection.png" class="align-center" src="../_images/bisection.png" style="width: 400px;" />
</a>
<section id="criterio-de-convergencia">
<h4><span class="section-number">6.2.1.1. </span>Criterio de convergencia<a class="headerlink" href="#criterio-de-convergencia" title="Link to this heading">#</a></h4>
<p>Para un nuevo valor <span class="math notranslate nohighlight">\(x_{k+1}\)</span> obtenido a partir de un valor <span class="math notranslate nohighlight">\(x_k\)</span>, definimos el <strong>criterio de convergencia</strong> en base a:</p>
<ul class="simple">
<li><p><strong>error absoluto</strong></p></li>
</ul>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
|x_{k+1} -x_{k}|
\end{equation*}\]</div>
<ul class="simple">
<li><p><strong>error relativo</strong>:</p></li>
</ul>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\frac{|x_{k+1} -x_{k}|}{|x_{k+1}|}
\end{equation*}\]</div>
<p>Es importante menciona que, en general, no existe una regla respecto al tipo de error que se debe usar como criterio de convergencia. La recomendación es usar el error absoluto si se tiene conocimiento de la función. Esto porque, a veces, el error relativo puede imponer condiciones demaciado estrictas para la convergencia.</p>
<p>Creemos una función en python para calcular raíces por medio del método de la bisección</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">def</span> <span class="nf">bisection</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">bracket</span><span class="p">,</span> <span class="n">xtol</span> <span class="o">=</span> <span class="mf">1E-5</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Método de la bisección para encontrar la raíz de f(x)</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">        - f: callable</span>
<span class="sd">            función de búsqueda de raíz, f(x)</span>
<span class="sd">            </span>
<span class="sd">        - bracket: tupple</span>
<span class="sd">            intervalo de búsqueda (a, b)</span>
<span class="sd">            </span>
<span class="sd">        - xtol: float (optional)</span>
<span class="sd">            tolerancia al error absoluto (1E-5 por defecto)</span>
<span class="sd">            </span>
<span class="sd">        - max_iter: int (opcional)</span>
<span class="sd">            número máximo de iteraciones (100 por defecto)</span>
<span class="sd">            </span>
<span class="sd">    Return</span>
<span class="sd">        - x_sol: float</span>
<span class="sd">            raíz de f(x)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">bracket</span> <span class="c1"># extraemos los valores del intervalo</span>
    
    <span class="c1"># verificamos si el intervalo [a,b] satisface el teorema del valor medio</span>
    <span class="k">assert</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">,</span> <span class="s2">&quot;El intervalo [a, b] no contiene raices&quot;</span>
    
    <span class="c1"># Asignamos valores arbitrarios para la primera iteración</span>
    <span class="n">x_old</span> <span class="o">=</span> <span class="n">a</span>  <span class="c1"># xk</span>
    <span class="n">x_new</span> <span class="o">=</span> <span class="n">b</span>  <span class="c1"># xk+1</span>
    
    <span class="c1"># loop si |xk+1 - xk| &gt; abs_tol</span>
    <span class="n">k_iter</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">abs_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_new</span> <span class="o">-</span> <span class="n">x_old</span><span class="p">)</span> <span class="c1"># error absoluto</span>
    <span class="k">while</span> <span class="n">abs_error</span> <span class="o">&gt;</span> <span class="n">xtol</span> <span class="ow">and</span> <span class="n">k_iter</span> <span class="o">&lt;</span> <span class="n">max_iter</span><span class="p">:</span>        
        
        <span class="c1"># imprimimos el intervalo en cada iteración (ESTO ES ILUSTRATIVO)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;k = </span><span class="si">%i</span><span class="s1">, (a,b) = (</span><span class="si">%.3f</span><span class="s1">, </span><span class="si">%.3f</span><span class="s1">), abs_error = </span><span class="si">%.3e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k_iter</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">abs_error</span><span class="p">))</span>
        
        <span class="c1"># evaluamos el intervalo acotado más cercano a x0</span>
        <span class="k">if</span>   <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">b</span> <span class="o">=</span> <span class="n">x_new</span>
        <span class="k">elif</span> <span class="n">f</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x_new</span>
            
        <span class="c1"># actualizamos xk y xk+1 para la siguiente itereación</span>
        <span class="n">x_old</span> <span class="o">=</span> <span class="n">x_new</span>
        <span class="n">x_new</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># punto medio entre [a, b]</span>
        
        <span class="n">abs_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_new</span> <span class="o">-</span> <span class="n">x_old</span><span class="p">)</span> <span class="c1"># nuevo error absoluto</span>
        <span class="n">k_iter</span> <span class="o">+=</span> <span class="mi">1</span>                       <span class="c1"># contamos la iteración</span>
    
    <span class="c1"># si la solución no converge y k_iter &gt; max_iter, informar a usuario</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_new</span> <span class="o">-</span> <span class="n">x_old</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">xtol</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;La solución no converge&#39;</span><span class="p">)</span>
    
    <span class="n">x_sol</span> <span class="o">=</span> <span class="n">x_new</span>
    <span class="k">return</span> <span class="n">x_sol</span> 
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># función de búsqueda de raíz</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="c1"># intervalo [a,b]</span>

<span class="c1"># Mostramos valor de f en los extremos [a, b] (solo para confirmación)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Análisis de intervalos&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a = </span><span class="si">%.3f</span><span class="s1">, f(a) = </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;b = </span><span class="si">%.3f</span><span class="s1">, f(b) = </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

<span class="c1"># </span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Resultado método de Bisección&#39;</span><span class="p">)</span>
<span class="n">x_sol</span> <span class="o">=</span> <span class="n">bisection</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">bracket</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x_sol = </span><span class="si">%.5f</span><span class="s1">, f(x_sol) = </span><span class="si">%.3e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x_sol</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_sol</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Análisis de intervalos
a = -1.000, f(a) = -0.632
b = 1.000, f(b) = 1.718

Resultado método de Bisección
k = 1, (a,b) = (-1.000, 1.000), abs_error = 2.000e+00
k = 2, (a,b) = (-1.000, 1.000), abs_error = 1.000e+00
k = 3, (a,b) = (-1.000, 0.000), abs_error = 5.000e-01
k = 4, (a,b) = (-1.000, -0.500), abs_error = 2.500e-01
k = 5, (a,b) = (-0.750, -0.500), abs_error = 1.250e-01
k = 6, (a,b) = (-0.750, -0.625), abs_error = 6.250e-02
k = 7, (a,b) = (-0.750, -0.688), abs_error = 3.125e-02
k = 8, (a,b) = (-0.719, -0.688), abs_error = 1.562e-02
k = 9, (a,b) = (-0.719, -0.703), abs_error = 7.812e-03
k = 10, (a,b) = (-0.711, -0.703), abs_error = 3.906e-03
k = 11, (a,b) = (-0.707, -0.703), abs_error = 1.953e-03
k = 12, (a,b) = (-0.705, -0.703), abs_error = 9.766e-04
k = 13, (a,b) = (-0.704, -0.703), abs_error = 4.883e-04
k = 14, (a,b) = (-0.704, -0.703), abs_error = 2.441e-04
k = 15, (a,b) = (-0.704, -0.703), abs_error = 1.221e-04
k = 16, (a,b) = (-0.703, -0.703), abs_error = 6.104e-05
k = 17, (a,b) = (-0.703, -0.703), abs_error = 3.052e-05
k = 18, (a,b) = (-0.703, -0.703), abs_error = 1.526e-05
x_sol = -0.70347, f(x_sol) = -1.712e-06
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="metodo-de-newton-raphson-intervalo-abierto">
<h3><span class="section-number">6.2.2. </span>Método de Newton-Raphson (intervalo abierto)<a class="headerlink" href="#metodo-de-newton-raphson-intervalo-abierto" title="Link to this heading">#</a></h3>
<p>Es el método de intervalo abierto más popular. Se origina a partir de series de Taylor</p>
<p>Supongamos que <span class="math notranslate nohighlight">\(x_0\)</span> es un punto cercano a la raíz de una función <span class="math notranslate nohighlight">\(f(x)\)</span>. Mediante la aproximación lineal, la raíz de la función <span class="math notranslate nohighlight">\(x_1\)</span> debe satisfacer la ecuación:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
0 = f(x_0) + f^{\prime}(x_0)(x_1-x_0),
\end{equation*}\]</div>
<p>Es decir, la raíz de <span class="math notranslate nohighlight">\(f(x)\)</span> está dada por:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
x_1 = x_0 - \frac{f(x_0)}{f^{\prime}(x_0)}
\end{equation*}\]</div>
<p>Si <span class="math notranslate nohighlight">\(x_1\)</span> no es la raíz, podemos encontrar un nuevo valor mediante <span class="math notranslate nohighlight">\(x_2 = x_1 - \frac{f(x_1)}{f^{\prime}(x_1)}\)</span></p>
<p>En resumen, el método de Newton-Raphson se define mediante la operación iterativa:</p>
<div class="amsmath math notranslate nohighlight" id="equation-c87b4156-8013-4f39-ac7a-37b821756daa">
<span class="eqno">(6.1)<a class="headerlink" href="#equation-c87b4156-8013-4f39-ac7a-37b821756daa" title="Permalink to this equation">#</a></span>\[\begin{equation}
x_{k+1} = x_k - \frac{f(x_k)}{f^{\prime}(x_k)}
\end{equation}\]</div>
<p>Gráficamente, lo que hacemos en cada iteración es encontrar el punto <span class="math notranslate nohighlight">\(x_{k+1}\)</span> donde la recta <span class="math notranslate nohighlight">\(f(x_k) + f^{\prime}(x_k)(x-x_k)\)</span> intersecta el eje <span class="math notranslate nohighlight">\(y = 0\)</span>.</p>
<a class="reference internal image-reference" href="../_images/newton_raphson.png"><img alt="../_images/newton_raphson.png" class="align-center" src="../_images/newton_raphson.png" style="width: 400px;" />
</a>
<p>La ventaja de este algoritmo es que, a diferencia de los métodos por intervalo acotado, solo necesita de un valor inicial. Esta es una caracterísca general de los métodos de intervalo abierto.</p>
<p>Una segunda ventaja radica en la rápida convergencia del algoritmo para encontrar soluciones.</p>
<a class="reference internal image-reference" href="../_images/newton_raphson_good.gif"><img alt="../_images/newton_raphson_good.gif" class="align-center" src="../_images/newton_raphson_good.gif" style="width: 600px;" />
</a>
<center> Fuente <a href="https://medium.com/@SereneBiologist/finding-beauty-in-bad-algorithms-799af003aee8/">Finding Beauty in Bad Algorithms</a></center><p>La siguiente función implementa el método de Newton-Raphson</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">def</span> <span class="nf">newton_raphson</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fprime</span><span class="p">,</span> <span class="n">xtol</span> <span class="o">=</span> <span class="mf">1E-5</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Método de Newton-Raphson para encontrar la raíz de f(x)</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        - x0: float</span>
<span class="sd">            valor inicial</span>
<span class="sd">            </span>
<span class="sd">        - f: callable</span>
<span class="sd">            función de búsqueda de raíz f(x)</span>
<span class="sd">            </span>
<span class="sd">        - fprime: callable</span>
<span class="sd">            derivada de la función de busqueda df/dx</span>
<span class="sd">            </span>
<span class="sd">        - xtol: float (optional)</span>
<span class="sd">            tolerancia al valor absoluto (1E-5 por defecto)</span>
<span class="sd">            </span>
<span class="sd">        - max_iter: int (optional)</span>
<span class="sd">            número máximo de iteraciones (100 por defecto)</span>
<span class="sd">            </span>
<span class="sd">    Return:</span>
<span class="sd">        x_sol: float</span>
<span class="sd">            raíz de f(x)</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">abs_error</span> <span class="o">=</span> <span class="mi">1000</span> <span class="c1"># inicializamos el error absoluto</span>
    <span class="n">x_old</span> <span class="o">=</span> <span class="n">x0</span>       <span class="c1"># valor inicial</span>
    
    <span class="c1"># comenzamos las iteraciones</span>
    <span class="n">k_iter</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">abs_error</span> <span class="o">&gt;</span> <span class="n">xtol</span> <span class="ow">and</span> <span class="n">k_iter</span> <span class="o">&lt;</span> <span class="n">max_iter</span><span class="p">:</span>

        <span class="c1"># newton-raphson</span>
        <span class="n">x_new</span> <span class="o">=</span> <span class="n">x_old</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x_old</span><span class="p">)</span><span class="o">/</span><span class="n">df</span><span class="p">(</span><span class="n">x_old</span><span class="p">)</span>
        
        <span class="c1"># imprimimos valor de x_new (SOLO ILUSTRATIVO)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;k = </span><span class="si">%i</span><span class="s1">, x_sol = </span><span class="si">%.3f</span><span class="s1">, abs_error = </span><span class="si">%.3e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k_iter</span><span class="p">,</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">abs_error</span><span class="p">))</span>
        
        <span class="c1"># calculamos error absoluto</span>
        <span class="n">abs_error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x_new</span> <span class="o">-</span> <span class="n">x_old</span><span class="p">)</span>
        
        <span class="c1"># actualizamos x0 y número de iteraciones</span>
        <span class="n">x_old</span> <span class="o">=</span> <span class="n">x_new</span>
        <span class="n">k_iter</span> <span class="o">+=</span> <span class="mi">1</span>
        
    <span class="c1"># si k_iter &gt; max_iter y la solución no converge, indicar al usuario</span>
    <span class="k">if</span> <span class="n">abs_error</span> <span class="o">&gt;</span> <span class="n">xtol</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;La solución no converge&#39;</span><span class="p">)</span>

    <span class="n">x_sol</span> <span class="o">=</span> <span class="n">x_new</span>
    <span class="k">return</span> <span class="n">x_sol</span>
</pre></div>
</div>
</div>
</div>
<p>Probamos el método para encontrar la raíz de <span class="math notranslate nohighlight">\(f(x) = e^{x} - x^2\)</span> con <span class="math notranslate nohighlight">\(f'(x) = e^{x} - 2x\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="n">df</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>

<span class="n">x0</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># valor inicial</span>
<span class="n">x_sol</span> <span class="o">=</span> <span class="n">newton_raphson</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x_sol = </span><span class="si">%.3f</span><span class="s1">, f(x_sol) = </span><span class="si">%.3e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x_sol</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_sol</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>k = 1, x_sol = -1.392, abs_error = 1.000e+03
k = 2, x_sol = -0.835, abs_error = 2.392e+00
k = 3, x_sol = -0.710, abs_error = 5.571e-01
k = 4, x_sol = -0.703, abs_error = 1.253e-01
k = 5, x_sol = -0.703, abs_error = 6.351e-03
k = 6, x_sol = -0.703, abs_error = 1.598e-05
x_sol = -0.703, f(x_sol) = 0.000e+00
</pre></div>
</div>
</div>
</div>
<p>En comparación con el método de la bisección, Newton-Raphson es capaz de encontrar la raíz con menor número de iteraciones.</p>
<section id="caso-f-x-no-es-analitica-metodo-de-la-secante">
<h4><span class="section-number">6.2.2.1. </span>Caso <span class="math notranslate nohighlight">\(f'(x)\)</span> no es analítica (Método de la secante)<a class="headerlink" href="#caso-f-x-no-es-analitica-metodo-de-la-secante" title="Link to this heading">#</a></h4>
<p>Otros métodos de intervalo abierto se diferencian de Newton-Raphson en la forma de determinar <span class="math notranslate nohighlight">\(f'(x)\)</span>. Esto debido a que no siempre es posible determinar la derviada de forma analítica.</p>
<p>Por ejemplo, en el <strong>método de la secante</strong>, aproxima <span class="math notranslate nohighlight">\(f'(x)\)</span> por <span class="math notranslate nohighlight">\(f'(x_k) = \frac{f(x_k) - f(x_{k-1})}{x_k - x_{k-1}}\)</span>, lo que deriva en la siguiente fórmula recursiva:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
x_{k+1} = x_k - \frac{f(x_k)(x_k - x_{k-1})}{f(x_k) - f(x_{k-1})}
\end{equation*}\]</div>
<p>Notar que, debido a esta fórmula, el método de la secante requiere <strong>dos valores iniciales, <span class="math notranslate nohighlight">\(x_0\)</span> y <span class="math notranslate nohighlight">\(x_1\)</span></strong></p>
</section>
<section id="problemas-de-convergencia">
<h4><span class="section-number">6.2.2.2. </span>Problemas de convergencia<a class="headerlink" href="#problemas-de-convergencia" title="Link to this heading">#</a></h4>
<p>Una desventaja general en los métodos de intervalo abierto es que pueden sufrir serios problemas de convergencia si el valor <span class="math notranslate nohighlight">\(x_k\)</span> cae en un punto de la función donde <span class="math notranslate nohighlight">\(f'(x_k) \approx 0\)</span></p>
<p>En esta animación vemos como el número de iteraciones “<span class="math notranslate nohighlight">\(n\)</span>” aumenta considerablemente debido a problemas de convergencia en los puntos <span class="math notranslate nohighlight">\(f'(x_k) \approx 0\)</span>. En la notación, <span class="math notranslate nohighlight">\(y = f(x_k)\)</span>
<a class="reference internal" href="../_images/newton_raphson_bad.gif"><img alt="../_images/newton_raphson_bad.gif" class="align-center" src="../_images/newton_raphson_bad.gif" style="width: 600px;" /></a></p>
<center> Fuente <a href="https://medium.com/@SereneBiologist/finding-beauty-in-bad-algorithms-799af003aee8/">Finding Beauty in Bad Algorithms</a></center></section>
<section id="control-de-la-solucion">
<h4><span class="section-number">6.2.2.3. </span>Control de la solución<a class="headerlink" href="#control-de-la-solucion" title="Link to this heading">#</a></h4>
<p>Otra desventaja de los métodos de intervalo abierto es que estos no tienen control sobre la raíz encontrada.</p>
<p>Por ejemplo, la función <span class="math notranslate nohighlight">\(f(x) = x^3 - 100x^2 - x + 100\)</span> tiene dos raíces <span class="math notranslate nohighlight">\(x^* = 1\)</span> y <span class="math notranslate nohighlight">\(x^* = 100\)</span>. Analicemos como Newton-Raphson entrega distintas soluciones dependiendo del valor inicial <span class="math notranslate nohighlight">\(x_0 = 0.01\)</span> y <span class="math notranslate nohighlight">\(x_0 = 0\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span>  <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">100</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">100</span>
<span class="n">df</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">200</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">x0</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># valor inicial</span>
<span class="n">x_sol</span> <span class="o">=</span> <span class="n">newton_raphson</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;x_sol = </span><span class="si">%.3f</span><span class="s1">, f(x_sol) = </span><span class="si">%.3e</span><span class="s1">&#39;</span> <span class="o">%</span> 
      <span class="p">(</span><span class="n">x_sol</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_sol</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>k = 1, x_sol = 100.000, abs_error = 1.000e+03
k = 2, x_sol = 100.000, abs_error = 1.000e+02
x_sol = 100.000, f(x_sol) = 0.000e+00
</pre></div>
</div>
</div>
</div>
<p>Notamos que:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{eqnarray*}
&amp;&amp;\mathrm{si~} x_0 = 0 &amp;\rightarrow&amp; x^* = 100. \\
&amp;&amp;\mathrm{si~} x_0 = 0.01 &amp;\rightarrow&amp; x^* = 1.
\end{eqnarray*}\]</div>
<p>Esto sucede debido a que <span class="math notranslate nohighlight">\(f'(0) = -1\)</span>. Así, para el valor inicial <span class="math notranslate nohighlight">\(x_0 = 0\)</span>, la segunda iteración nos da <span class="math notranslate nohighlight">\(x_1 = 0 - \frac{100}{-1} = 100\)</span>, que es una raíz de <span class="math notranslate nohighlight">\(f(x)\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%capture</span> showplot
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mf">110.1</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>           <span class="c1"># Tamaño de figura</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">18</span><span class="p">})</span> <span class="c1"># Tamaño de fuente</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;f(x)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Gráfica de $x^3 - 100x^2 - x + 100$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">showplot</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/74db804530785d58b31636deb2305bcb50f65bfc5875c6f3099fb0a181e103fe.png" src="../_images/74db804530785d58b31636deb2305bcb50f65bfc5875c6f3099fb0a181e103fe.png" />
</div>
</div>
</section>
</section>
<section id="metodos-combinados">
<h3><span class="section-number">6.2.3. </span>Métodos combinados<a class="headerlink" href="#metodos-combinados" title="Link to this heading">#</a></h3>
<p>Los metodos más sofisticados para búsqueda de raices combinan métodos de intervalo abierto y cerrado. Por un lado, el método de intervalo abierto permite una convergencia más rápida, mientras que el método de intervalo cerrado permite acotar la solución.</p>
<p>En términos generales, los métodos combinados operan de la siguente forma.</p>
<ul class="simple">
<li><p>Se subdivide el dominio de la función para identificar intervalos donde existan raices.</p></li>
<li><p>Se procede con la iteración mediante un método de intervalo abierto</p></li>
<li><p>Si la solución se mueve fuera del intervalo acotado, se procede a iterar con un método de intervalo cerrado.</p></li>
</ul>
<p>Por ejemplo, el <strong>método de Brent’s</strong> combina un método de intervalo abierto (como Newton-Raphson o secante), con el método de la bisección. Más información en las referencias</p>
</section>
<section id="raices-de-funcion-escalar-en-python">
<h3><span class="section-number">6.2.4. </span>Raices de función escalar en python<a class="headerlink" href="#raices-de-funcion-escalar-en-python" title="Link to this heading">#</a></h3>
<p>En python, la función <code class="docutils literal notranslate"><span class="pre">root_scalar</span></code> de la librería <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code>, permite determinar raíces de una función escalar.</p>
<p>Los argumento más relevantes en esta función son:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">root_scalar</span>
<span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span>            <span class="c1"># callable, función objetivo</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(),</span>      <span class="c1"># tuple (opcional), argumentos extra para la función</span>
            <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># str (opcional), tipo de método</span>
            <span class="n">bracket</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="c1"># 2 floats list (opcional), intervalo de búsqueda de raíces</span>
            <span class="n">fprime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># callable (opcional), primera derivada</span>
            <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>      <span class="c1"># float (opcional), valor inicial</span>
            <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>      <span class="c1"># float (opcional), 2do valor inicial (para aproximar derivada)</span>
            <span class="n">xtol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>    <span class="c1"># float (opcional), tolerancia para error absoluto</span>
            <span class="n">rtol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>    <span class="c1"># float (opcional), tolerancia para error relativo</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="kc">None</span>  <span class="c1"># int (opcional), número máximo de operaciones</span>
           <span class="p">)</span>
</pre></div>
</div>
<p>La función tiene implementada distintos métodos de intervalo abierto, cerrado y combinados, tales como: bisección (<code class="docutils literal notranslate"><span class="pre">bisect</span></code>), Newton-Raphson (<code class="docutils literal notranslate"><span class="pre">newton</span></code>), secante (<code class="docutils literal notranslate"><span class="pre">secant</span></code>) y Brent’s (<code class="docutils literal notranslate"><span class="pre">brentq</span></code> o <code class="docutils literal notranslate"><span class="pre">brenth</span></code>). El tipo de método debe ir indicado en <code class="docutils literal notranslate"><span class="pre">method</span></code>:</p>
<p>Además de la función objetivo, se debe indicar un valor inicial, dos valores iniciales o un intervalo. Con esto <code class="docutils literal notranslate"><span class="pre">root_scalar</span></code> definirá el tipo de método dependiendo del input:</p>
<ul class="simple">
<li><p>Un valor inicial <span class="math notranslate nohighlight">\(x_0\)</span> (variable <code class="docutils literal notranslate"><span class="pre">x0</span></code>), y la derivada (variable <code class="docutils literal notranslate"><span class="pre">fprime</span></code>) <span class="math notranslate nohighlight">\(\rightarrow\)</span> método de intervalo abierto o híbrido</p></li>
<li><p>Dos valores iniciales <span class="math notranslate nohighlight">\(x_0\)</span> (variable <code class="docutils literal notranslate"><span class="pre">x0</span></code>) y <span class="math notranslate nohighlight">\(x_1\)</span> (variable <code class="docutils literal notranslate"><span class="pre">x1</span></code>) <span class="math notranslate nohighlight">\(\rightarrow\)</span> método de intervalo abierto o híbrido</p></li>
<li><p>Un intervalo. (variable <code class="docutils literal notranslate"><span class="pre">bracket</span></code>)  <span class="math notranslate nohighlight">\(\rightarrow\)</span> método de intervalo cerrado o híbrido</p></li>
</ul>
<p>El tipo de argumento para cada método está indicado en la siguiente tabla (x=requerido, o=opcional):</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p><code class="docutils literal notranslate"><span class="pre">method</span></code></p></th>
<th class="head text-center"><p><code class="docutils literal notranslate"><span class="pre">f</span></code></p></th>
<th class="head text-center"><p><code class="docutils literal notranslate"><span class="pre">args</span></code></p></th>
<th class="head text-center"><p><code class="docutils literal notranslate"><span class="pre">brackets</span></code></p></th>
<th class="head text-center"><p><code class="docutils literal notranslate"><span class="pre">x0</span></code></p></th>
<th class="head text-center"><p><code class="docutils literal notranslate"><span class="pre">x1</span></code></p></th>
<th class="head text-center"><p><code class="docutils literal notranslate"><span class="pre">fprime</span></code></p></th>
<th class="head text-center"><p><code class="docutils literal notranslate"><span class="pre">xtol</span></code></p></th>
<th class="head text-center"><p><code class="docutils literal notranslate"><span class="pre">rtol</span></code></p></th>
<th class="head text-center"><p><code class="docutils literal notranslate"><span class="pre">maxiter</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">'bisect'</span></code></p></td>
<td class="text-center"><p>x</p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p>x</p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p>o</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">'brentq'</span></code></p></td>
<td class="text-center"><p>x</p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p>x</p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p>o</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">'brenth'</span></code></p></td>
<td class="text-center"><p>x</p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p>x</p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p>o</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">'secant'</span></code></p></td>
<td class="text-center"><p>x</p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p>x</p></td>
<td class="text-center"><p>x</p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p>o</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">'newton'</span></code></p></td>
<td class="text-center"><p>x</p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p>x</p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p>x</p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p>o</p></td>
<td class="text-center"><p>o</p></td>
</tr>
</tbody>
</table>
</div>
<p>Por ejemplo, analizamos la raíz de la función <span class="math notranslate nohighlight">\(f(x) = x^3 - 1\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">root_scalar</span>
<span class="n">f</span>  <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># función objetivo f(x)</span>
<span class="n">df</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span>   <span class="c1"># primera derivada de f(x)</span>
</pre></div>
</div>
</div>
</div>
<p>Usamor <code class="docutils literal notranslate"><span class="pre">roor_scalar</span></code> con el argumento <code class="docutils literal notranslate"><span class="pre">method</span></code> para especificar el tipo de método que queremos utilizar</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Bisección:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>      <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;bisect&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Newton-Raphson:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x0</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="n">fprime</span><span class="o">=</span><span class="n">df</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;newton&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Secante:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>        <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x0</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="n">x1</span><span class="o">=</span><span class="mf">0.21</span>  <span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;secant&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Bisección:
       converged: True
           flag: converged
 function_calls: 43
     iterations: 41
           root: 1.0000000000004547

Newton-Raphson:
       converged: True
           flag: converged
 function_calls: 22
     iterations: 11
           root: 1.0

Secante:
       converged: True
           flag: converged
 function_calls: 23
     iterations: 22
           root: 1.0
</pre></div>
</div>
</div>
</div>
<p>Si omitimos el argumento <code class="docutils literal notranslate"><span class="pre">method</span></code>, <code class="docutils literal notranslate"><span class="pre">root_scalar</span></code> utilizará el método más adecuado en base al tipo de input (<code class="docutils literal notranslate"><span class="pre">x0</span></code>, <code class="docutils literal notranslate"><span class="pre">bracket</span></code>, <code class="docutils literal notranslate"><span class="pre">fprime</span></code>, ect)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Brent´s:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>                                      <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;brentq&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Intervalo (método por defecto):</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>               <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Cond. inicial y derivada (método po defecto):</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x0</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="n">fprime</span><span class="o">=</span><span class="n">df</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Brent´s:
       converged: True
           flag: converged
 function_calls: 11
     iterations: 10
           root: 1.0

Intervalo (método por defecto):
       converged: True
           flag: converged
 function_calls: 11
     iterations: 10
           root: 1.0

Cond. inicial y derivada (método po defecto):
       converged: True
           flag: converged
 function_calls: 22
     iterations: 11
           root: 1.0
</pre></div>
</div>
</div>
</div>
<p>Si hacemos <code class="docutils literal notranslate"><span class="pre">sol</span> <span class="pre">=</span> <span class="pre">root_scalar</span></code>, la variable <code class="docutils literal notranslate"><span class="pre">sol</span></code> almacena la información desplegada anteriormente mediante <code class="docutils literal notranslate"><span class="pre">print</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sol</span> <span class="o">=</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;raíz x*=</span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sol</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>raíz x*=1.000
</pre></div>
</div>
</div>
</div>
<p>También podemos extraer el valor de la raíz directamente mediante <code class="docutils literal notranslate"><span class="pre">root_scalar(...).root</span></code></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;raíz x*=</span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>raíz x*=1.000
</pre></div>
</div>
</div>
</div>
<p>Para controlar la tolerancia en <code class="docutils literal notranslate"><span class="pre">root_scalar</span></code> podemos usar:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xtol</span></code> para el error absoluto, por ejemplo:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sol</span> <span class="o">=</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1E-5</span><span class="p">)</span> <span class="c1"># error absoluto de 0.00001 </span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rtol</span></code> para el error realtivo, por ejemplo:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sol</span> <span class="o">=</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">rtol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span> <span class="c1"># error relativo de 0.1%</span>
</pre></div>
</div>
<p>También podemos usar combinaciones de ambas. En ese caso, la iteración finalizará cuando se cumpla cualquiera de los dos criterios.</p>
<p>Por último, también podemos definir el numero máximo de iteraciones mediante <code class="docutils literal notranslate"><span class="pre">maxiter</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sol</span> <span class="o">=</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span> <span class="c1"># máximo 1000 iteraciones</span>
</pre></div>
</div>
<p>Para mayor información revisar la <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root_scalar.html">documentación oficial</a>.</p>
</section>
</section>
<section id="busqueda-de-raices-para-funciones-vectoriales">
<h2><span class="section-number">6.3. </span>Búsqueda de raíces para funciones vectoriales<a class="headerlink" href="#busqueda-de-raices-para-funciones-vectoriales" title="Link to this heading">#</a></h2>
<p>Una función vectorial es una función con una o más variables dependientes, que entrega un vector de múltiples dimensiones.</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
f: x\in \mathbb{R}^n \rightarrow \mathbb{R}^m
\end{equation*}\]</div>
<p>Consideremos el siguiente sistema de ecuaciones:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
x\log(y^2-1) &amp;= 3 \\
y\sin(2x^3) + e^y &amp;= 2
\end{align*}\]</div>
<p>Resolver este sistema, es equivalente a encontrar las raices de una función vetorial del tipo:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\vec{F}(x,y) = \Bigg\{
\begin{matrix}
f(x,y) &amp;= x\log(y^2-1) - 3 \\
g(x,y) &amp;= y\sin(2x^3) + e^y - 2
\end{matrix}
\end{equation*}\]</div>
<p>Así, resolver un sistema de ecuaciones de <span class="math notranslate nohighlight">\(n\)</span> incognitas, es equivalente a encontrar las raices de una función vectorial del tipo:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
f: x\in \mathbb{R}^n \rightarrow \mathbb{R}^n
\end{equation*}\]</div>
<p>En este capítulo revisaremos los aspectos generales de los métodos numéricos para resolver este problema.</p>
<section id="metodos-de-busqueda-lineal">
<h3><span class="section-number">6.3.1. </span>Métodos de búsqueda lineal<a class="headerlink" href="#metodos-de-busqueda-lineal" title="Link to this heading">#</a></h3>
<p>Para un vector <span class="math notranslate nohighlight">\(\vec{x} = \{x_1, x_2, ... x_n\}\)</span>, y una función vectorial <span class="math notranslate nohighlight">\(\vec{F}\left(\vec{x}\right) = \big\{f_1\left(\vec{x}\right),f_2\left(\vec{x}\right), ... f_n\left(\vec{x}\right)\big\}\)</span>, consideremos la forma generalizada del método de Newton-Raphson:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\vec{x}_k = \vec{x}_{k-1} - {\left[\bar{J}(\vec{x}_{k-1})\right]}^{-1}\cdot \vec{F}\left(\vec{x}_{k-1}\right) 
\end{equation*}\]</div>
<p>donde <span class="math notranslate nohighlight">\(\bar{J} = \nabla\vec{F}\)</span> es el <strong>Jacobiano</strong> de <span class="math notranslate nohighlight">\(\vec{F}\)</span>.</p>
<p>El <strong>operador <span class="math notranslate nohighlight">\(\nabla \vec{F}\)</span> corresponde a una matriz</strong>, donde cada elemento está dado por la derivada parcial de una componente de la función respecto a un parámetro independiente, es decir: <span class="math notranslate nohighlight">\(J_{ij} = \frac{\partial f_i}{\partial x_j}\)</span></p>
<p>Por ejemplo, para una función vectorial <span class="math notranslate nohighlight">\(\vec{F}(x,y) = \big\{f(x,y), g(x,y)\big\}\)</span>, el Jacobiano está dado por:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\bar{J}(x,y) = 
\left[
\begin{matrix}
\frac{\partial f}{\partial x} &amp; \frac{\partial f}{\partial y} \\
\frac{\partial g}{\partial x} &amp; \frac{\partial g}{\partial y}
\end{matrix}\right]
\end{equation*}\]</div>
<p>En otras palabras, el Jacobiano es equivalente a la derivada pero para funciones vectoriales.</p>
<p>El método generalizado de Newton-Raphson, así, consiste en encontrar un nuevo vector <span class="math notranslate nohighlight">\(\vec{x}_{k+1}\)</span> a partir de la pendiente descendiente definida en el vector <span class="math notranslate nohighlight">\(\vec{x}_{k}\)</span>.</p>
<p>Sin embargo, a diferencia del caso unidimensional, el Jacobiano entrega multiples direcciones posibles. ¿Como saber cuál es la dirección que minimiza <span class="math notranslate nohighlight">\(\vec{F}\)</span>?</p>
<p>Para definir la dirección descendiente se considera el criterio:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\mathrm{min}\left[\vec{F}\cdot\vec{F}\right] 
\end{equation*}\]</div>
<p>Así, el problema de busqueda de raíces de una función vectorial se transforma en un problema de minimización.</p>
<p>Esta es la estrategia de los <strong>métodos de búsqueda lineal</strong>.</p>
<p>Entre los más conocidos tenemos el <strong>método de Broyden</strong>. Más información en las referencias</p>
</section>
<section id="metodos-de-region-de-confianza">
<h3><span class="section-number">6.3.2. </span>Métodos de región de confianza<a class="headerlink" href="#metodos-de-region-de-confianza" title="Link to this heading">#</a></h3>
<p>En general, determinar el Jacobiano de una función vectorial es complicado. A raíz de esto nacen los métodos de región de confianza, los cuales se basan en una aproximación de <span class="math notranslate nohighlight">\(\vec{F}\)</span> en forma de paraboloide. Esta aproximación simplifica el cálculo del Jacobiano.</p>
<p>Se define como <strong>región de confianza a la región donde la función puede ser aproximada por un parabolide</strong>.</p>
<p>En términos generales, los métodos de región de confianza operan de la siguiente forma:</p>
<ul class="simple">
<li><p>Se define una región de confianza inicial y se busca un mínimo dentro esa región.</p></li>
<li><p>Si el valor encontrado minimiza <span class="math notranslate nohighlight">\(\vec{F}\cdot\vec{F}\)</span>, se construye una aproximación hyperboloide de <span class="math notranslate nohighlight">\(\vec{F}\)</span> y se incrementa la región de confianza.</p></li>
<li><p>Si el valor encontrado no minisa <span class="math notranslate nohighlight">\(\vec{F}\cdot\vec{F}\)</span>, se reduce la región de confianza, y se vuelve a buscar el mínimo.</p></li>
<li><p>El algoritmo itera hasta encontrar un mínimo global de <span class="math notranslate nohighlight">\(\vec{F}\)</span>.</p></li>
</ul>
<p>En general, los métodos de región de confianza son más estables que los métodos de búsqueda lineal, y son los métodos por defecto en funciones de python.</p>
<p>Mayor información sobre estos métodos <a class="reference external" href="http://www.applied-mathematics.net/optimization/optimizationIntro.html">acá</a></p>
</section>
<section id="raices-de-funcion-vectorial-en-python">
<h3><span class="section-number">6.3.3. </span>Raíces de función vectorial en python<a class="headerlink" href="#raices-de-funcion-vectorial-en-python" title="Link to this heading">#</a></h3>
<p>En python, la función <code class="docutils literal notranslate"><span class="pre">fsolve</span></code> de la librería <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code> permite encontrar las raíces de una función vectorial.</p>
<p>Los principales inputs de la función son:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fsolve</span><span class="p">(</span><span class="n">func</span><span class="p">,</span>             <span class="c1"># función vectorial objetivo (callable)</span>
                      <span class="n">x0</span><span class="p">,</span>               <span class="c1"># valores iniciales</span>
                      <span class="n">args</span><span class="o">=</span><span class="p">(),</span>          <span class="c1"># argumentos extras para la iteración</span>
                      <span class="n">xtol</span><span class="o">=</span><span class="mf">1.49012e-08</span>  <span class="c1"># tolerancia al error relativo</span>
                     <span class="p">)</span>
</pre></div>
</div>
<p>La función se basa en los algoritmos de región de confianza “hybrd” y “hybrj” de la libreria <code class="docutils literal notranslate"><span class="pre">MINPACK</span></code>. Más detalles <a class="reference external" href="https://www.math.utah.edu/software/minpack/minpack/hybrj.html">acá</a></p>
<p>La función <code class="docutils literal notranslate"><span class="pre">fsolve</span></code> requiere, como mínimo, la función vectorial y los valores iniciales.</p>
<p>Por ejemplo, queremos resolver el sistema</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
x\cos(y)=4 \\
xy-y=5
\end{align*}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fsolve</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="p">]</span>

<span class="n">root</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;la solución es: &#39;</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>la solución es:  [6.50409711 0.90841421]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">func</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[3.732125719579926e-12, 1.617106448748018e-11]
</pre></div>
</div>
</div>
</div>
<p>También podemos definir el error absoluto mediante la instrucción <code class="docutils literal notranslate"><span class="pre">xtol</span></code> (por defecto, <code class="docutils literal notranslate"><span class="pre">xtol=1.49012e-08</span></code>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xtol</span> <span class="o">=</span> <span class="mf">1E-10</span><span class="p">)</span> <span class="c1"># |xk+1 - xk| &lt; 1E-10</span>
</pre></div>
</div>
<p>Para mayor información, revisar la <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fsolve.html">documentación oficial</a></p>
</section>
</section>
<section id="referencias">
<h2><span class="section-number">6.4. </span>Referencias<a class="headerlink" href="#referencias" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Kong Q., Siauw T., Bayen A. M. <strong>Chapter 19: Root Finding</strong> in <em><a class="reference external" href="https://pythonnumericalmethods.berkeley.edu/notebooks/chapter17.00-Interpolation.html">Python Programming and Numerical Methods – A Guide for Engineers and Scientists</a></em>, 1st Ed., Academic Press, 2021</p></li>
<li><p>Chapra S., Canale R. <strong>Parte dos: Raíces de ecuaciones</strong> en <em>Métodos Numéricos para Ingenieros</em>, 6ta Ed., McGraw Hill, 2011</p></li>
<li><p>Williams H. P. <strong>Chapter 9: Root Finding and Nonlinear Sets of Equations</strong> in “Numerical Recipes” 3rd Ed, Cambridge University Press, 2007</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./06-Root-finding"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../05-Taylor-series/05-Taylor-series.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">5. </span>Series de Taylor</p>
      </div>
    </a>
    <a class="right-next"
       href="../07-Integracion/07-Integracion.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">7. </span>Integración numérica</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduccion">6.1. Introducción</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#busqueda-de-raices-para-una-funcion-escalar">6.2. Búsqueda de raíces para una función escalar</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodo-de-la-biseccion-intervalo-acotado">6.2.1. Método de la Bisección (intervalo acotado)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#criterio-de-convergencia">6.2.1.1. Criterio de convergencia</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodo-de-newton-raphson-intervalo-abierto">6.2.2. Método de Newton-Raphson (intervalo abierto)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#caso-f-x-no-es-analitica-metodo-de-la-secante">6.2.2.1. Caso <span class="math notranslate nohighlight">\(f'(x)\)</span> no es analítica (Método de la secante)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#problemas-de-convergencia">6.2.2.2. Problemas de convergencia</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#control-de-la-solucion">6.2.2.3. Control de la solución</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodos-combinados">6.2.3. Métodos combinados</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#raices-de-funcion-escalar-en-python">6.2.4. Raices de función escalar en python</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#busqueda-de-raices-para-funciones-vectoriales">6.3. Búsqueda de raíces para funciones vectoriales</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodos-de-busqueda-lineal">6.3.1. Métodos de búsqueda lineal</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodos-de-region-de-confianza">6.3.2. Métodos de región de confianza</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#raices-de-funcion-vectorial-en-python">6.3.3. Raíces de función vectorial en python</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#referencias">6.4. Referencias</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Francisco V. Ramirez-Cuevas
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>