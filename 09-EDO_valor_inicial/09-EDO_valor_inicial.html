

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>9. Problemas de valor inicial &#8212; MEC301 - Métodos Numéricos</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom_edits.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=3ee479438cf8b5e0d341"></script>

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '09-EDO_valor_inicial/09-EDO_valor_inicial';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="10. Problema de valor en la frontera" href="../10-EDO_condicion_de_borde/10-EDO_condicion_de_borde.html" />
    <link rel="prev" title="8. Derivación numérica" href="../08-Derivacion_numerica/08-Derivacion_numerica.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
  
    <p class="title logo__title">MEC301 - Métodos Numéricos</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Bienvenidos al curso
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Parte 1. Introducción a los métodos numéricos</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../01-Aspectos_generales/01-Aspectos_generales.html">1. Aspectos generales de programación y algoritmos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02-Algebra_lineal/02-Algebra_lineal.html">2. Algebra lineal y sistemas de ecuaciones lineales</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03-Ajuste_de_curvas/03-Ajuste_de_curvas.html">3. Ajuste de curvas por mínimos cuadrados</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04-Interpolacion/04-Interpolacion.html">4. Métodos de Interpolación</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Parte 2. Métodos numéricos basados en series de Taylor</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../05-Taylor-series/05-Taylor-series.html">5. Series de Taylor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06-Root-finding/06-Root-finding.html">6. Algortimos de búsqueda de raíces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07-Integracion/07-Integracion.html">7. Integración numérica</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Parte 3. Métodos numéricos para ecuaciones diferenciales</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../08-Derivacion_numerica/08-Derivacion_numerica.html">8. Derivación numérica</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">9. Problemas de valor inicial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10-EDO_condicion_de_borde/10-EDO_condicion_de_borde.html">10. Problema de valor en la frontera</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11-DiferenciasFinitas_EDP/11-DiferenciasFinitas_EDP.html">11. Diferencias finitas para ecuaciones diferenciales parciales</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://colab.research.google.com/github/PanxoPanza/metodos_numericos_mec301/blob/main/09-EDO_valor_inicial/09-EDO_valor_inicial.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onColab"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="../_static/images/logo_colab.png">
  </span>
<span class="btn__text-container">Colab</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/09-EDO_valor_inicial/09-EDO_valor_inicial.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Problemas de valor inicial</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduccion">9.1. Introducción</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#clasificacion-de-ecuaciones-diferenciales">9.1.1. Clasificación de ecuaciones diferenciales</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#condiciones-de-borde-y-condiciones-iniciales">9.1.2. Condiciones de borde y condiciones iniciales</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#aspectos-generales-de-los-metodos-numericos-para-solucion-de-odes">9.2. Aspectos generales de los métodos numéricos para solución de ODEs</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ecuacion-diferencial-ordinaria-edo-con-valor-inicial">9.2.1. Ecuación diferencial ordinaria (EDO) con valor inicial</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodo-de-euler-explicito">9.2.2. Método de Euler explícito</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#presicion">9.2.3. Presición</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#estabilidad">9.2.4. Estabilidad</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodo-de-euler-implicito">9.2.5. Método de Euler implícito</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metodos-de-paso-simple-runge-kutta">9.3. Métodos de paso simple (Runge-Kutta)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#runge-kutta-de-segundo-orden-rk2">9.3.1. Runge-Kutta de segundo orden (RK2)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#runge-kutta-de-cuarto-orden-rk4">9.3.2. Runge-Kutta de cuarto orden (RK4)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metodos-multipasos">9.4. Métodos multipasos</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solucion-de-edos-en-python-scipy-integrate-solve-ivp">9.5. Solución de EDOs en python (<code class="docutils literal notranslate"><span class="pre">scipy.integrate.solve_ivp</span></code>)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rigidez-en-edos">9.6. Rigidez en EDOs</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rigidez">9.6.1. Rigidez</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recomendaciones">9.6.2. Recomendaciones</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#referencias">9.7. Referencias</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="problemas-de-valor-inicial">
<h1><span class="section-number">9. </span>Problemas de valor inicial<a class="headerlink" href="#problemas-de-valor-inicial" title="Permalink to this heading">#</a></h1>
<section id="introduccion">
<h2><span class="section-number">9.1. </span>Introducción<a class="headerlink" href="#introduccion" title="Permalink to this heading">#</a></h2>
<p>Las ecuaciones diferenciales son utilizadas para modelar sistemas en todos los campos de ciencia e ingeniería.</p>
<p>Como definición general, un <strong>sistema de ecuaciones diferenciales</strong> define la relación entre variables dependiente, <span class="math notranslate nohighlight">\(f_1(x_1,x_2,x_3, \cdots), f_2(x_1,x_2,x_3, \cdots), \cdots\)</span>, las variables independientes <span class="math notranslate nohighlight">\(x_1,x_2,x_3, \cdots\)</span>, y sus derivadas.</p>
<section id="clasificacion-de-ecuaciones-diferenciales">
<h3><span class="section-number">9.1.1. </span>Clasificación de ecuaciones diferenciales<a class="headerlink" href="#clasificacion-de-ecuaciones-diferenciales" title="Permalink to this heading">#</a></h3>
<p>Una ecuacion diferencial puede estar compuesta por <strong>una variable dependiente y una independiente</strong>.</p>
<p>Por ejemplo, la <strong>ecuación del péndulo</strong> que define la variación temporal del ángulo <span class="math notranslate nohighlight">\(\Theta\)</span> en función del tiempo <span class="math notranslate nohighlight">\(t\)</span>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-9f97f836-b7b9-4d6d-a59a-5d43926b4184">
<span class="eqno">(9.1)<a class="headerlink" href="#equation-9f97f836-b7b9-4d6d-a59a-5d43926b4184" title="Permalink to this equation">#</a></span>\[\begin{equation}
ml\frac{d^2}{dt^2}\Theta(t) + \kappa l\frac{d}{dt}\Theta(t) + mg \sin \Theta(t) = 0
\end{equation}\]</div>
<p>donde <span class="math notranslate nohighlight">\(g\)</span> es la gravedad, <span class="math notranslate nohighlight">\(m\)</span> la masa del péndulo, <span class="math notranslate nohighlight">\(l\)</span> es la distancia al centro de rotación y <span class="math notranslate nohighlight">\(\kappa\)</span> es una constante a amortiguación asociado al arrastre por el viento</p>
<a class="reference internal image-reference" href="../_images/ecuacion_pendulo.png"><img alt="../_images/ecuacion_pendulo.png" class="align-center" src="../_images/ecuacion_pendulo.png" style="width: 300px;" /></a>
<p>Este tipo de ecuaciones se conoce como <strong>ecuación diferencial ordinaria (EDO)</strong>, debido a que la varible dependiente (<span class="math notranslate nohighlight">\(\Theta\)</span>, en este caso) está condicionada por una variable independiente (<span class="math notranslate nohighlight">\(t\)</span>, en este caso). Debido al término <span class="math notranslate nohighlight">\(\sin\Theta\)</span>, esta ecuación corresponde a una <strong>EDO no-lineal</strong>.</p>
<p>Si el ángulo de oscilación, <span class="math notranslate nohighlight">\(\Theta\)</span>, es pequeño, podemos hacer la simplificación <span class="math notranslate nohighlight">\(\sin \Theta\approx \Theta\)</span>.</p>
<p>En este caso la ecuación se transforma en una <strong>EDO lineal</strong>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-b3cbb722-3c36-4d58-8ac7-a9a36839fe26">
<span class="eqno">(9.2)<a class="headerlink" href="#equation-b3cbb722-3c36-4d58-8ac7-a9a36839fe26" title="Permalink to this equation">#</a></span>\[\begin{equation}
ml\frac{d^2\Theta(t)}{dt^2} = - mg \Theta(t) -\kappa \dot{\Theta}(t) 
\end{equation}\]</div>
<p>En general, las EDO lineales tiene solución analítica.</p>
<p>También podemos tener una ecuación diferencial definida para una variable dependiente y multiples variables independientes.</p>
<p>Un buen ejemplo es la <em><strong>ecuación de difusión de calor</strong></em>, que describe la distribución de temperatura en función del tiempo, <span class="math notranslate nohighlight">\(t\)</span>, y el espacio. En el caso 2D:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
k\frac{\partial T}{\partial x^2}+
k\frac{\partial T}{\partial y^2} = \rho c_p \frac{\partial T}{\partial t}
\end{equation*}\]</div>
<p>donde <span class="math notranslate nohighlight">\(\rho\)</span> es la densidad, <span class="math notranslate nohighlight">\(c_p\)</span> es el calor específico, y <span class="math notranslate nohighlight">\(k\)</span> es la conductividad térmica</p>
<p>Este tipo de ecuacion, con más de una variable independiente, se conocen como <strong>ecuación diferencial parcial (EDP)</strong></p>
<p>En este caso, la <strong>EDP es del tipo lineal</strong></p>
<p>Por último, en el caso de más de una variable dependiente, podemos tener <strong>sistemas de ecuaciones diferenciales del tipo EDO o EDP</strong>.</p>
<p>Tal es el caso de la <em><strong>ecuación de Navier-Stokes</strong></em> utilizada en mecánica de fluidos para modelar un problema en dos dimenciones:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\frac{\partial u}{\partial t}+u\frac{\partial u}{\partial x}+v\frac{\partial u}{\partial y} &amp;= -\frac{1}{\rho}\frac{\partial p}{\partial x}+\nu \left(\frac{\partial^2 u}{\partial x^2}+\frac{\partial^2 u}{\partial y^2} \right) \\
\frac{\partial v}{\partial t}+u\frac{\partial v}{\partial x}+v\frac{\partial v}{\partial y} &amp;= -\frac{1}{\rho}\frac{\partial p}{\partial y}+\nu\left(\frac{\partial^2 v}{\partial x^2}+\frac{\partial^2 v}{\partial y^2}\right) \\
\frac{\partial^2 p}{\partial x^2}+\frac{\partial^2 p}{\partial y^2} &amp;= -\rho\left(\frac{\partial u}{\partial x}\frac{\partial u}{\partial x}+2\frac{\partial u}{\partial y}\frac{\partial v}{\partial x}+\frac{\partial v}{\partial y}\frac{\partial v}{\partial y} \right)
\end{align*}\]</div>
<p>En este caso tenemos un sistema de <strong>3 EDPs no-lineales</strong> definido para tres variables dependientes (<span class="math notranslate nohighlight">\(u\)</span>, <span class="math notranslate nohighlight">\(v\)</span>, y <span class="math notranslate nohighlight">\(p\)</span>) en función de tres variables independientes (tiempo <span class="math notranslate nohighlight">\(t\)</span> y el espacio <span class="math notranslate nohighlight">\(x\)</span> e <span class="math notranslate nohighlight">\(y\)</span>). Donde <span class="math notranslate nohighlight">\(u(t,x,y)\)</span> y <span class="math notranslate nohighlight">\(v(t,x,y)\)</span> son, respectivamente, el campo de velocidad en dirección <span class="math notranslate nohighlight">\(\hat{x}\)</span> y <span class="math notranslate nohighlight">\(\hat{y}\)</span>; y <span class="math notranslate nohighlight">\(p(t,x,y)\)</span> es el campo de presiones. Nuevamente, <span class="math notranslate nohighlight">\(\rho\)</span>, es la densidad del fluido.</p>
<p>También podemos <strong>clasificar una ecuación diferencial según el orden de sus derivadas.</strong></p>
<p>Por ejemplo, la ecuación:</p>
<div class="amsmath math notranslate nohighlight" id="equation-a5e730a8-adc0-49c6-9215-2ff9cd696956">
<span class="eqno">(9.3)<a class="headerlink" href="#equation-a5e730a8-adc0-49c6-9215-2ff9cd696956" title="Permalink to this equation">#</a></span>\[\begin{equation}
ml\frac{d^2}{dt^2}\Theta(t) + \kappa\frac{d}{dt}\Theta(t) + mg \sin \Theta(t) = 0
\end{equation}\]</div>
<p>Es una <strong>EDO de segundo orden,</strong> debido a que <span class="math notranslate nohighlight">\(\Theta\)</span> es derivada dos veces respecto a <span class="math notranslate nohighlight">\(t\)</span>.</p>
</section>
<section id="condiciones-de-borde-y-condiciones-iniciales">
<h3><span class="section-number">9.1.2. </span>Condiciones de borde y condiciones iniciales<a class="headerlink" href="#condiciones-de-borde-y-condiciones-iniciales" title="Permalink to this heading">#</a></h3>
<p>Las ecuaciones diferenciales presentadas anteriormente representan una formulación general asociada a un fenómeno físco (movimiento de un péndulo, distribución de temperaturas o movimiento de un fluido). Sin embargo, estas ecuaciones no están condicionadas a un problema en específico y, por lo tanto, su solución es definida en base a constantes de valor arbitrario.</p>
<p>Por ejemplo, la versión lineal de la EDO del péndulo tiene como solución general:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\Theta(t) = Ae^{-\lambda t} + Be^{+\lambda t}
\end{equation*}\]</div>
<p>Para asociar una ecuacion diferencial a un problema específico necesitamos <strong>condiciones de borde</strong> o <strong>condiciones iniciales</strong></p>
<p>Usamos <strong>condiciones iniciales si la variable dependiente <em>evoluciona</em> respecto a la variable independiente.</strong></p>
<p>Por ejemplo, en el caso del péndulo, el ángulo <span class="math notranslate nohighlight">\(\Theta\)</span> evoluciona respecto al tiempo, <span class="math notranslate nohighlight">\(t\)</span>, y por lo tanto necesitamos de condiciones inciales.</p>
<p>Como condición inicial, por ejemplo, asumamos que el péndulo está en reposo con un ángulo <span class="math notranslate nohighlight">\(\Theta_0\)</span>:</p>
<p><strong>Ecuación gobernante</strong></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
ml\frac{d^2}{dt^2}\Theta(t) + \kappa\frac{d}{dt}\Theta(t) + mg \sin \Theta(t) = 0
\end{equation*}\]</div>
<p><strong>Condiciones iniciales</strong></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\dot{\Theta}(t = 0) &amp;= 0 \\
\Theta(t = 0) &amp;= \Theta_0
\end{align*}\]</div>
<blockquote>
<div><p><strong>Nota</strong> El número de condiciones iniciales debe ser igual al número de derivadas de la variable independiente.</p>
</div></blockquote>
<p>Comúnmente, las condiciones iniciales están asociadas a la variable tiempo. Sin embargo, una condición inicial también puede estar asociada a una variable espacial.</p>
<p>Por ejemplo, la ecuación que describe el cambio de temperatura del agua (<span class="math notranslate nohighlight">\(T_f\)</span>) a lo largo del eje axial (<span class="math notranslate nohighlight">\(y\)</span>) de los tubos de un colector solar está dado por:</p>
<p><strong>Ecuación gobernante</strong></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\dot{m}c_p\frac{dT_f}{dy} - nWF'\left[S - U_L(T_f - T_a)\right] = 0
\end{equation*}\]</div>
<p><strong>Condición de borde</strong></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
T_f(y = 0) = T_{f,i}
\end{equation*}\]</div>
<p>donde <span class="math notranslate nohighlight">\(T_{f,i}\)</span> es la temperatura del agua a la entrada del colector, <span class="math notranslate nohighlight">\(\dot{m}\)</span> es el flujo másico de agua por el colector, <span class="math notranslate nohighlight">\(T_a\)</span> es la temperatura ambiente, <span class="math notranslate nohighlight">\(S\)</span> es la radiación solar absorbida, <span class="math notranslate nohighlight">\(c_p\)</span> es el calor específico del agua, <span class="math notranslate nohighlight">\(U_L\)</span> es el coeficiente global de transferencia de calor, y <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(W\)</span> y <span class="math notranslate nohighlight">\(F'\)</span> son parámetros de diseño del colector.</p>
<p>En este caso, la temperatura del agua (<span class="math notranslate nohighlight">\(T_f\)</span>) <em><strong>evoluciona</strong></em> al recorrer el eje axial de los tubos. Así, este problema también podría ser considerado como un problema con <strong>valor inicial</strong>.</p>
<p><strong>Usamos condiciones de borde si la variable dependiente está condicionada por diversos puntos de una variable dependiente.</strong></p>
<p>Por ejemplo, la distribución de temperaturas de una placa cuadrada de largo <span class="math notranslate nohighlight">\(L\)</span>, incialmente a temperatura <span class="math notranslate nohighlight">\(T_a\)</span>, con temperaturas en <span class="math notranslate nohighlight">\(T_h\)</span> y <span class="math notranslate nohighlight">\(T_c\)</span> en los bordes izquierdo y derecho, y tempertura <span class="math notranslate nohighlight">\(T_0\)</span> en la parte superior e inferior, está descrita por la ecuación:</p>
<p><strong>Ecuación gobernante</strong></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
k\frac{\partial T}{\partial x^2}+
k\frac{\partial T}{\partial y^2} = \rho c_p \frac{\partial T}{\partial t}
\end{equation*}\]</div>
<p><strong>Condiciones de borde</strong></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
T(t,0,y) = T_h,\quad\quad T(t,L,y) = T_c \\
T(t,x,0) = T_a, \quad\quad T(t,x,L) = T_a \\
\end{align*}\]</div>
<p><strong>condición inicial</strong></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
T(0,x,y) = T_a
\end{equation*}\]</div>
<p><strong>El número de condiciones de borde debe ser igual al número de derivadas respecto a la variable independiente</strong></p>
<p>Las condiciones de borde están, generalmente, asociadas a variables en el espacio</p>
</section>
</section>
<section id="aspectos-generales-de-los-metodos-numericos-para-solucion-de-odes">
<h2><span class="section-number">9.2. </span>Aspectos generales de los métodos numéricos para solución de ODEs<a class="headerlink" href="#aspectos-generales-de-los-metodos-numericos-para-solucion-de-odes" title="Permalink to this heading">#</a></h2>
<section id="ecuacion-diferencial-ordinaria-edo-con-valor-inicial">
<h3><span class="section-number">9.2.1. </span>Ecuación diferencial ordinaria (EDO) con valor inicial<a class="headerlink" href="#ecuacion-diferencial-ordinaria-edo-con-valor-inicial" title="Permalink to this heading">#</a></h3>
<p>En forma general, podemos representar una EDO con valor inicial de la forma:</p>
<div class="amsmath math notranslate nohighlight" id="equation-f7024e95-3cb1-4dfa-9674-72fe8f8e5024">
<span class="eqno">(9.4)<a class="headerlink" href="#equation-f7024e95-3cb1-4dfa-9674-72fe8f8e5024" title="Permalink to this equation">#</a></span>\[\begin{equation}
\frac{d^{n}f(t)}{dt^{n}} = F\left(t, f(t), \frac{df(t)}{dt}, \frac{d^2f(t)}{dt^2}, \frac{d^3f(t)}{dt^3}, \ldots, \frac{d^{n-1}f(t)}{dt^{n-1}}\right) ,
\end{equation}\]</div>
<p>sujeta a las condiciones inciales:
<span class="math notranslate nohighlight">\(t = 0, f(0), f^{(1)}(0), f^{(2)}(0),\ldots, f^{(n)}(0)\)</span></p>
<p>Por ejemplo, en el caso de la ecuación del péndulo:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\frac{d^2}{dt^2}\Theta(t) = F(t,\Theta, \dot{\Theta}) 
\end{equation*}\]</div>
<p>donde <span class="math notranslate nohighlight">\( F(t,\Theta, \dot{\Theta})  = - \frac{g}{l}\sin \Theta - \frac{\kappa}{ml}\dot{\Theta}
\)</span></p>
<p>Convenientemente, podemos reescribir esta ecuación como:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{eqnarray*}
\frac{d}{dt}\Theta(t) &amp;=&amp; \dot{\Theta} &amp;=&amp; F_1(t,\Theta, \dot{\Theta}) \\
\frac{d}{dt}\dot{\Theta}(t) &amp;=&amp; - \frac{g}{l}\sin \Theta - \frac{\kappa}{ml}\dot{\Theta} &amp;=&amp; F_2(t,\Theta, \dot{\Theta}),  
\end{eqnarray*}\]</div>
<p>que en su forma matricial se reduce a</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\frac{d}{dt}\left\{\begin{matrix} \Theta \\ \dot{\Theta}\end{matrix}\right\} = \left\{\begin{matrix} F_1(t,\Theta,\dot{\Theta}) \\ F_2(t,\Theta,\dot{\Theta})\end{matrix}\right\},
\end{equation*}\]</div>
<p>con condición inicial</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\left\{\begin{matrix} \Theta(0) \\ \dot{\Theta(0)}\end{matrix}\right\} = \left\{\begin{matrix} \Theta_0 \\ 0\end{matrix}\right\}
\end{equation*}\]</div>
<p>A partir de este procedimiento, <strong>hemos reducido una EDO de orden superior a una EDO de primer orden de la forma</strong>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-0c19805d-b05f-4842-a512-128b8e8c00e3">
<span class="eqno">(9.5)<a class="headerlink" href="#equation-0c19805d-b05f-4842-a512-128b8e8c00e3" title="Permalink to this equation">#</a></span>\[\begin{equation}
\frac{d}{dt}\vec{y} = \vec{F}(t,\vec{y})
\end{equation}\]</div>
<p>con una condición inicial <span class="math notranslate nohighlight">\(\vec{y}(0)\)</span>.</p>
<p>donde</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\vec{y} = \left\{\begin{matrix} \Theta \\ \dot{\Theta}\end{matrix}\right\},\quad
\vec{F}(t,\vec{y}) = \left\{\begin{matrix} F_1(t,\Theta,\dot{\Theta}) \\ F_2(t,\Theta,\dot{\Theta})\end{matrix}\right\},\quad
\vec{y}(0) = \left\{\begin{matrix} \Theta_0 \\ 0\end{matrix}\right\}
\end{equation*}\]</div>
<p>Como cololario general, tenemos que <strong>siempre podemos transformar una EDO de orden superior a un sistema de EDOs de primer orden</strong></p>
<p>Esto nos permite enfocarnos en métodos numéricos para resolver una EDO (o un sistema de EDOs) de primer orden.</p>
</section>
<section id="metodo-de-euler-explicito">
<h3><span class="section-number">9.2.2. </span>Método de Euler explícito<a class="headerlink" href="#metodo-de-euler-explicito" title="Permalink to this heading">#</a></h3>
<p>Dada la condición inicial <span class="math notranslate nohighlight">\(\vec{y}(t_0)\)</span>, supongamos que queremos determinar el valor de <span class="math notranslate nohighlight">\(\vec{y}\)</span> en un tiempo <span class="math notranslate nohighlight">\(t_0 +\Delta t\)</span>.</p>
<p>La forma más sencilla es mediante una expansión de Taylor centrada en <span class="math notranslate nohighlight">\(t_0\)</span>:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\vec{y}(t_0 +\Delta t) = \vec{y}(t_0)+\frac{d}{dt}\vec{y}(t_0)\Delta t +\frac{d^2}{dt^2}\vec{y}(t_0)\Delta t^2 + \cdots
\end{equation*}\]</div>
<p>Truncando los términos de segundo y mayor orden tenemos:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\vec{y}(t_0 +\Delta t) = \vec{y}(t_0)+\vec{F}[t_0,\vec{y}(t_0)]\Delta t + O(\Delta t^2)
\end{equation*}\]</div>
<p>Podemos seguir repetiendo este procedimiento para encontrar la evolución <span class="math notranslate nohighlight">\(\vec{y}\)</span> en el tiempo.</p>
<p>En su forma general, este método se conoce como el <strong>método de Euler explícito</strong>:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\vec{y}_{i+1} = \vec{y}_i+h\vec{F}\left(t_i,\vec{y}_i\right) + O(h^2)
\end{equation*}\]</div>
<p>donde <span class="math notranslate nohighlight">\(\vec{y}_{i+1} = \vec{y}(t_i + \Delta t)\)</span>, y <span class="math notranslate nohighlight">\(h = \Delta t\)</span></p>
<p>Gráficamente, el método consiste en aproximar el valor de <span class="math notranslate nohighlight">\(\vec{y}_{i+1}\)</span> mediante una recta en el punto <span class="math notranslate nohighlight">\(t_i, \vec{y}_i\)</span>, cuya pendiente es <span class="math notranslate nohighlight">\(\vec{F}[t_i,\vec{y}_i]\)</span></p>
<a class="reference internal image-reference" href="../_images/Euler_schematic.png"><img alt="../_images/Euler_schematic.png" class="align-center" src="../_images/Euler_schematic.png" style="width: 350px;" /></a>
<p>Por ejemplo, consideremos la ecuación diferencial:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\frac{dy}{dt} = e^{-2t}
\end{equation*}\]</div>
<p>con condición inicial <span class="math notranslate nohighlight">\(y(0) = -0.5\)</span></p>
<p>Utilicemos el método de Euler para resolver este problema en el intervalo <span class="math notranslate nohighlight">\(t\in[0,1]\)</span> con <span class="math notranslate nohighlight">\(h = 0.1\)</span> y <span class="math notranslate nohighlight">\(h = 0.01\)</span>. Compararemos nuestra solución con la solución exacta <span class="math notranslate nohighlight">\(y(t) = -\frac{1}{2}e^{-2t}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Solución exacta</span>
<span class="n">y_exact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="c1"># Definimos parámetros numéricos</span>
<span class="n">h</span> <span class="o">=</span> <span class="mf">0.01</span>                       <span class="c1"># paso de tiempo (dt)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>      <span class="c1"># lista de tiempos (arreglo desde 0 a 1s)</span>

<span class="c1"># Escribimos ecuación diferencial en formato de código </span>
<span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="c1"># Ecuación gobernante dy = F(t,y)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span>                     <span class="c1"># Condición inicial</span>

<span class="c1"># Método de Euler</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>          <span class="c1"># arreglo vacio para y</span>
<span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># Euler explicito</span>
    
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span> <span class="c1"># Tamaño de fuente</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ro--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Euler&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y_exact</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Solución exacta&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Evaluación ecuación $\frac</span><span class="si">{dy}{dt}</span><span class="s1"> = e^{-2t}; y(0) = -0.5$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;y(t)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/e1cb9839b9b2f83437754a7acb602dfcf3ef1e7637cc2ad06fda9ca436eb924e.png" src="../_images/e1cb9839b9b2f83437754a7acb602dfcf3ef1e7637cc2ad06fda9ca436eb924e.png" />
</div>
</div>
</section>
<section id="presicion">
<h3><span class="section-number">9.2.3. </span>Presición<a class="headerlink" href="#presicion" title="Permalink to this heading">#</a></h3>
<p>En el ejemplo anterior, notamos una considerable <strong>mejora en la aproximación cuando disminumos <span class="math notranslate nohighlight">\(h\)</span></strong>, de <span class="math notranslate nohighlight">\(h = 0.1\)</span> a <span class="math notranslate nohighlight">\(h = 0.01\)</span>. Esto es una <strong>consecuencia directa del error de truncamiento <span class="math notranslate nohighlight">\(O(h^2)\)</span>.</strong></p>
<p>Por otro lado, en ambos casos notamos que <strong>el error aumenta a medida que nos alejamos del valor inicial</strong>. Esta propagación del error ocurre porque el error de truncamiento nos entrega una estimación del error local, es decir, durante un solo paso del método.</p>
<p>En base a esto, <strong>caracterizamos la presición de un método considerando dos tipos de error</strong>:</p>
<ul class="simple">
<li><p><strong>Error de truncamiento local:</strong> Error del método para predecir la siguiente iteración (es decir, <span class="math notranslate nohighlight">\(i\rightarrow i+1\)</span>). Este error está asociado al truncamiento de la serie de Taylor.</p></li>
<li><p><strong>Error de truncamiento global:</strong> Error por acumulación de errores de truncamiento local a lo largo de toda la iteración.</p></li>
</ul>
</section>
<section id="estabilidad">
<h3><span class="section-number">9.2.4. </span>Estabilidad<a class="headerlink" href="#estabilidad" title="Permalink to this heading">#</a></h3>
<p>Otro término relevante en los métodos de solución de EDOs es la <strong>estabilidad.</strong> A diferencia de la precisión, que depende solo del método numérico escogido, <strong>la estabilidad depende de la EDO a resolver y del método escogido</strong>.</p>
<p>Es decir, un método puede ser estable para algunos problemas e inestable para otros.</p>
<p>Analicemos el problema de estabilidad con la siguiente EDO:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\frac{dy}{dt} = -20y
\end{equation*}\]</div>
<p>con condición inicial <span class="math notranslate nohighlight">\(y(0) = 0.5\)</span></p>
<p>Utilicemos el método de Euler para encontrar la solución en el intervalo <span class="math notranslate nohighlight">\(t\in[0,1]\)</span> con <span class="math notranslate nohighlight">\(h = 0.09\)</span> y <span class="math notranslate nohighlight">\(h = 0.01\)</span>. Compararemos nuestra solución con la solución exacta <span class="math notranslate nohighlight">\(y(t) = 0.5e^{-20t}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Solución exacta</span>
<span class="n">y_exact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="c1"># Definimos parámetros numéricos</span>
<span class="n">h</span> <span class="o">=</span> <span class="mf">0.05</span>                       <span class="c1"># paso de tiempo</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>      <span class="c1"># lista de tiempos </span>
 
<span class="c1"># Ecuación diferencial </span>
<span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">y</span>        <span class="c1"># Ecuación gobernante dy = F(t,y)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">0.5</span>                      <span class="c1"># Condición inicial</span>

<span class="c1"># Método de Euler</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span> <span class="c1"># Tamaño de fuente</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ro--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Euler&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y_exact</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Solución exacta&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Evaluación ecuación $\frac</span><span class="si">{dy}{dt}</span><span class="s1"> = e^{-2t}; y(0) = -0.5$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;y(t)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/d7b719df50204b213a276f1f0e3495bb7da2cc0cae4309204dd1714823784121.png" src="../_images/d7b719df50204b213a276f1f0e3495bb7da2cc0cae4309204dd1714823784121.png" />
</div>
</div>
<p>Observamos que el método de Euler converge cuando <span class="math notranslate nohighlight">\(h = 0.01\)</span>, pero oscila constantemente para <span class="math notranslate nohighlight">\(h &gt; 0.1\)</span>. Esta es un característica típica de un problema de estabilidad.</p>
<p>Es posible demostrar que para ecuaciones del tipo <span class="math notranslate nohighlight">\(\frac{dy}{dt} = -ay\)</span>, la condición de estabilidad del método de Euler explícito está dada por <span class="math notranslate nohighlight">\(h &gt; 2/a\)</span>.</p>
<p>En otras palabras, el método de Euler explícito es <strong>condicionalmente estable</strong></p>
</section>
<section id="metodo-de-euler-implicito">
<h3><span class="section-number">9.2.5. </span>Método de Euler implícito<a class="headerlink" href="#metodo-de-euler-implicito" title="Permalink to this heading">#</a></h3>
<p>Alternativamente, podemos definir el argumento de <span class="math notranslate nohighlight">\(\vec{F}(t,\vec{y})\)</span> en función de los valores futuros <span class="math notranslate nohighlight">\(t_{i+1}\)</span> y <span class="math notranslate nohighlight">\(\vec{y}_{i+1}\)</span>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-3ce265e5-c649-4033-ac32-5b95b0e06a3d">
<span class="eqno">(9.6)<a class="headerlink" href="#equation-3ce265e5-c649-4033-ac32-5b95b0e06a3d" title="Permalink to this equation">#</a></span>\[\begin{equation}
\vec{y}_{i+1} = \vec{y}_i+h\vec{F}\left(t_{i+1},\vec{y}_{i+1}\right) + O(h^2)
\end{equation}\]</div>
<p>Esta formulación se define como <strong>implícita</strong> debido a que el valor futuro, <span class="math notranslate nohighlight">\(\vec{y}_{i+1}\)</span> se encuentra a ambos lados de la ecuación.</p>
<p>Así, llamamos a este algoritmo <strong>Método de Euler implícito</strong>.</p>
<p>Si bien esta formulación también tiene un error de truncamiento <span class="math notranslate nohighlight">\(O(h^2)\)</span>, es más estable que Euler explícito (lo veremos con un ejemplo).</p>
<p>Notar que la formulación implícita da lugar a valores desconocidos, <span class="math notranslate nohighlight">\(y_{i+1}\)</span>, al lado derecho de la ecuación. Esto implica que, <strong>para cada iteración debemos resolver un sistema de ecuaciones para encontrar <span class="math notranslate nohighlight">\(\vec{y}_{i+1}\)</span>.</strong></p>
<p>Debido a que, en general, el sistema de ecuaciones que encontraremos es no lineal, <strong>debemos utilizar un método de solución de raices para encontrar <span class="math notranslate nohighlight">\(\vec{y}_{i+1}\)</span> (por ejemplo, Newton-Raphson).</strong></p>
<p>En otras palabras, dado un tiempo inicial <span class="math notranslate nohighlight">\(t_0\)</span> y condiciones iniciales <span class="math notranslate nohighlight">\(\vec{y}_0\)</span>, el valor de <span class="math notranslate nohighlight">\(\vec{y}_1\)</span> está dado por las raices de:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\vec{y}_{1} - \left[\vec{y}_0 - h\vec{F}\left(t_{1},\vec{y}_{1}\right)\right] = 0
\end{equation*}\]</div>
<p>Para encontrar el valor en el tiempo <span class="math notranslate nohighlight">\(t_2, t_3, \dots,t_n\)</span>, repetimos el procedimiento anterior de forma iterativa, resolviendo la ecuación:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\vec{y}_{i+1} - \left[\vec{y}_i - h\vec{F}\left(t_{i+1},\vec{y}_{i+1}\right)\right] = 0
\end{equation*}\]</div>
<p>Revisemos esto con el ejemplo anterior, ahora usando Euler implícito.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fsolve</span>

<span class="c1"># Solución exacta</span>
<span class="n">y_exact</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="c1"># Definimos parámetros numéricos</span>
<span class="n">h</span> <span class="o">=</span> <span class="mf">0.1</span>                   <span class="c1"># paso de tiempo</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>  <span class="c1"># lista de tiempos </span>

<span class="c1"># Ecuación diferencial </span>
<span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="mi">20</span><span class="o">*</span><span class="n">y</span>    <span class="c1"># Ecuación gobernante dy = F(t,y)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">0.5</span>                  <span class="c1"># Condición inicial</span>

<span class="c1"># Método de Euler</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>      <span class="c1"># inicializamos arreglo para yi+1</span>
<span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span>                 <span class="c1"># guardamos condicion inicial</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># itereamos según paso de tiempo</span>
    
    <span class="c1"># Guardamos valores conocidos</span>
    <span class="n">ti</span><span class="p">,</span> <span class="n">ti1</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="c1"># Definimos la función objetivo para la búsqueda de raices</span>
    <span class="n">E_implicit</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">yi1</span><span class="p">:</span> <span class="n">yi1</span> <span class="o">-</span> <span class="p">(</span><span class="n">yi</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">F</span><span class="p">(</span><span class="n">ti1</span><span class="p">,</span> <span class="n">yi1</span><span class="p">))</span>
    
    <span class="c1"># Buscamos la raiz de forma iterativa con valor inicial y0</span>
    <span class="n">ysol</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">E_implicit</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">yi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ysol</span> <span class="c1"># Guardamos el valor para la siguiente iteración</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span> <span class="c1"># Tamaño de fuente</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ro--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Euler implícito&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y_exact</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Solución exacta&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Evaluación ecuación $\frac</span><span class="si">{dy}{dt}</span><span class="s1"> = e^{-2t}; y(0) = -0.5$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;y(t)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/c35c5afb64e2ab2f048d76b9d90074d5f4fbcfbc25811be6fbdb1da903fef3ee.png" src="../_images/c35c5afb64e2ab2f048d76b9d90074d5f4fbcfbc25811be6fbdb1da903fef3ee.png" />
</div>
</div>
<p>En el ejemplo vemos que, si bien la precisión sigue condicionada al error de truncamiento <span class="math notranslate nohighlight">\(O(h^2)\)</span>, el método no presenta problemas de inestabilidad</p>
<p>En efecto, para ODEs de la forma <span class="math notranslate nohighlight">\(\frac{dy}{dt} = -ay\)</span>, el métodod de Euler implícito es <em><strong>incondicionalmente estable</strong></em>.</p>
<p>En resumen, en la solución de una ODE debemos considerar la precisión y la estabilidad del problema. Si bien, <strong>la precisión está exclusivamente asociada al método, la estabilidad depende del método y la EDO a resolver.</strong></p>
<p>En el ejemplo anterior fue posible cuantificar las condiciones de estabilidad debido a que la EDO era del tipo lineal. <strong>En general, no siempre es posible acotar la inestabilidad de forma analítica, especialmente para EDOs no lineales.</strong></p>
<p>En la práctica, los términos precisión y estabilidad se confunden debido a que comúnmente ambos están asociados por <span class="math notranslate nohighlight">\(h\)</span>. Sin embargo, cada uno es un aspecto independiente. Así, <strong>un método con poca precisión puede ser muy estable, y viceversa.</strong></p>
</section>
</section>
<section id="metodos-de-paso-simple-runge-kutta">
<h2><span class="section-number">9.3. </span>Métodos de paso simple (Runge-Kutta)<a class="headerlink" href="#metodos-de-paso-simple-runge-kutta" title="Permalink to this heading">#</a></h2>
<p>Los métodos de Runge-Kutta (RK) permiten aumentar el número de términos de una serie de Taylor, sin la necesidad de calcular derivadas de mayor orden</p>
<p>Esto permite una mejor precisión, ya que el error de truncamiento local se reduce.</p>
<p>Existen muchas variaciones, todas asociadas a una aproximación de la forma:</p>
<div class="amsmath math notranslate nohighlight" id="equation-97cdfa6f-d65d-456e-9b0a-f623758d5ea5">
<span class="eqno">(9.7)<a class="headerlink" href="#equation-97cdfa6f-d65d-456e-9b0a-f623758d5ea5" title="Permalink to this equation">#</a></span>\[\begin{equation}
y_{i+1} = y_i + \phi h
\end{equation}\]</div>
<p>donde <span class="math notranslate nohighlight">\(\phi\)</span> se conoce como <em>función incremento</em>, que <strong>representa una pendiente representativa del intervalo</strong></p>
<p>En su forma general, la función incremento está dada por:</p>
<div class="amsmath math notranslate nohighlight" id="equation-2a273e59-4c05-46be-bd30-fc3196f2f746">
<span class="eqno">(9.8)<a class="headerlink" href="#equation-2a273e59-4c05-46be-bd30-fc3196f2f746" title="Permalink to this equation">#</a></span>\[\begin{equation}
\phi = a_1k_1+a_2k_2+\cdots+a_nk_n
\end{equation}\]</div>
<p>donde <span class="math notranslate nohighlight">\(a_j\)</span> son constantes, y los valores <span class="math notranslate nohighlight">\(k_j\)</span> son:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
k_1 &amp;= F(x_i,y_i) \\
k_2 &amp;= F(x_i+p_1h,y_i+q_{11}k_1h) \\
k_3 &amp;= F(x_i+p_2h,y_i+q_{21}k_1h+q_{22}k_2h) \\
\vdots \\
k_n &amp;= F(x_i+p_{n-1}h,y_i+q_{n-1,1}k_1h++q_{n-1,2}k_2h+\cdots q_{n-1,n-1}k_{n-1}h) \\
\end{align*}\]</div>
<p>donde <span class="math notranslate nohighlight">\(p_m\)</span> y <span class="math notranslate nohighlight">\(q_{m,n}\)</span> son constantes.</p>
<p>Notar que los valores de <span class="math notranslate nohighlight">\(k_j\)</span> están definidos por recurrencia, es decir <span class="math notranslate nohighlight">\(k_j\)</span> depende de <span class="math notranslate nohighlight">\(k_{j-1}, k_{j-2}, \cdots, k_{1}\)</span></p>
<p>Para obtener una formulación específica debemos especificar <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>Una vez definido el valor de <span class="math notranslate nohighlight">\(n\)</span>, los valores de <span class="math notranslate nohighlight">\(a_j\)</span>, <span class="math notranslate nohighlight">\(p_m\)</span> y <span class="math notranslate nohighlight">\(q_{m,n}\)</span> se determinan igualando la expresión <span class="math notranslate nohighlight">\(y_{i+1} = y_i + \phi h\)</span> con los términos de la expansión de Taylor (<a class="reference external" href="https://pythonnumericalmethods.berkeley.edu/notebooks/chapter22.05-Predictor-Corrector-Methods.html#second-order-runge-kutta-method">más info acá</a>):</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
y(t_{i+1}) &amp;= y(t_i) + y'(t_i)h + \frac{1}{2!}y''(t_i)h^2 + \cdots + \frac{1}{n!}y^{(n)}(t_i)h^n \\
 &amp;= y(t_i) + F(t_i,y_i)h + \frac{1}{2!}F'(t_i,y_i)h^2 + \cdots + \frac{1}{n!}F^{(n-1)}(t_i,y_i)h^n 
\end{align*}\]</div>
<p>Así, por ejemplo, la formulación para <span class="math notranslate nohighlight">\(n = 1\)</span> permite aproximar hasta la primera derivada de la serie de Taylor y, por lo tanto, tiene un error de truncamiento local <span class="math notranslate nohighlight">\(O(h^2)\)</span>.</p>
<p><strong>La formula RK1 corresponde al método de Euler explícito.</strong></p>
<section id="runge-kutta-de-segundo-orden-rk2">
<h3><span class="section-number">9.3.1. </span>Runge-Kutta de segundo orden (RK2)<a class="headerlink" href="#runge-kutta-de-segundo-orden-rk2" title="Permalink to this heading">#</a></h3>
<p>La versión de segundo orden de RK es:</p>
<div class="amsmath math notranslate nohighlight" id="equation-9961cfd7-30a2-4693-88c6-cb9eeb7a3e69">
<span class="eqno">(9.9)<a class="headerlink" href="#equation-9961cfd7-30a2-4693-88c6-cb9eeb7a3e69" title="Permalink to this equation">#</a></span>\[\begin{equation}
y_{i+1} = y_i + (a_1k_1+a_2k_2)h + O(h^3)
\end{equation}\]</div>
<p>donde:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
k_1 &amp;= F(t_i,y_i) \\
k_2 &amp;= F(t_i+p_1h,y_i+q_{11}k_1h)
\end{align*}\]</div>
<p>y las constantes <span class="math notranslate nohighlight">\(a_1\)</span>, <span class="math notranslate nohighlight">\(a_2\)</span>, <span class="math notranslate nohighlight">\(p_1\)</span> y <span class="math notranslate nohighlight">\(q_{11}\)</span>, están dadas por:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
a_1+a_2 = 1 \\
a_2p_1 = 1/2 \\
a_2q_{11} = 1/2
\end{align*}\]</div>
<p>Debido a que tenemos 3 ecuaciones y 4 incognitas, se debe acotar una de las variables para resolver el sistema</p>
<p>Esto da lugar a distintas versiones para RK2. Acá destacamos 2 (hay más versiones), que se conocen como <strong>métodos del tipo <em>predictor-corrector</em></strong>.</p>
<p><strong>Método de Heun (<span class="math notranslate nohighlight">\(a_2 = 1/2\)</span>)</strong></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
y_{i+1} = y_i + \left(\frac{1}{2}k_1+\frac{1}{2}k_2\right)h
\end{equation*}\]</div>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
k_1 &amp;= F(t_i,y_i) \\
k_2 &amp;= F(t_i+h,y_i+k_1h)
\end{align*}\]</div>
<a class="reference internal image-reference" href="../_images/Heun_method.png"><img alt="../_images/Heun_method.png" class="align-center" src="../_images/Heun_method.png" style="width: 700px;" /></a>
<p><strong>Método del punto medio (<span class="math notranslate nohighlight">\(a_2 = 1\)</span>)</strong></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
y_{i+1} = y_i + k_2h
\end{equation*}\]</div>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
k_1 &amp;= F(t_i,y_i) \\
k_2 &amp;= F(t_i+h/2,y_i+k_1h/2)
\end{align*}\]</div>
<a class="reference internal image-reference" href="../_images/Midpoint_method.png"><img alt="../_images/Midpoint_method.png" class="align-center" src="../_images/Midpoint_method.png" style="width: 700px;" /></a>
</section>
<section id="runge-kutta-de-cuarto-orden-rk4">
<h3><span class="section-number">9.3.2. </span>Runge-Kutta de cuarto orden (RK4)<a class="headerlink" href="#runge-kutta-de-cuarto-orden-rk4" title="Permalink to this heading">#</a></h3>
<p>Los métodos RK de cuarto orden son los más populares. Al igual que con RK2, existen muchas versiones. La más popular es:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
y_{i+1} = y_i + \frac{1}{6}\left(k_1+2k_2+2k_3+k_4\right)h  + O(h^5)
\end{equation*}\]</div>
<p>donde:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
k_1 &amp;= F(t_i,y_i) \\
k_2 &amp;= F\left(t_i+\frac{1}{2}h,y_i+\frac{1}{2}k_1h\right) \\
k_3 &amp;= F\left(t_i+\frac{1}{2}h,y_i+\frac{1}{2}k_2h\right) \\
k_4 &amp;= F\left(t_i+h,y_i+k_3h\right)
\end{align*}\]</div>
</section>
</section>
<section id="metodos-multipasos">
<h2><span class="section-number">9.4. </span>Métodos multipasos<a class="headerlink" href="#metodos-multipasos" title="Permalink to this heading">#</a></h2>
<p>Los métodos discutidos hasta ahora se clasifican como <strong>métodos de paso simple</strong> debido a que el valor futuro <span class="math notranslate nohighlight">\(y_{i+1}\)</span> es determinado exclusivamente por la predicción anterior en el tiempo <span class="math notranslate nohighlight">\(t_i\)</span>. Esto implica que los métodos no retienen la información para la predicción de aproximaciones en itereciones futuras (es decir, <span class="math notranslate nohighlight">\(y_2\)</span> considera es resutlado en <span class="math notranslate nohighlight">\(t_1\)</span>, pero no en <span class="math notranslate nohighlight">\(t_0\)</span>).</p>
<p>Este comportamiento hace que los métodos de paso simple sean ineficientes para problemas clasificados como <em>rígidos</em>, algo que discutiremos al final de esta unidad.</p>
<p>Los <strong>métodos multipasos, o de paso múltiple</strong> corrigen este comportamiento mediante polinomios de interpolación construidos a partir de una serie de estimaciones en tiempos previos, permitiendo mejorar la estimación de la trayectoria de la solución.</p>
<p>Esta característica, por otro lado, impica que <strong>los métodos multipasos demandan mayor capacidad de memoria que los métodos de paso simple.</strong></p>
<p><strong>Otra desventaja</strong> es que, debido a que los métodos multipaso requieren condiciones iniciales en varios pasos anteriores, <strong>se deben utilizar métodos alternativos (como de paso simple) para generar estos valores iniciales.</strong></p>
<p>Los métodos más utilizados son los métodos de Adams-Bashforth, Adamns-Moulton y las <strong>fórmulas de diferenciación hacia atrás (BDFs)</strong>. Esta última está implementada en la librería python oficial para resolver EDO con valor inicial.</p>
</section>
<section id="solucion-de-edos-en-python-scipy-integrate-solve-ivp">
<h2><span class="section-number">9.5. </span>Solución de EDOs en python (<code class="docutils literal notranslate"><span class="pre">scipy.integrate.solve_ivp</span></code>)<a class="headerlink" href="#solucion-de-edos-en-python-scipy-integrate-solve-ivp" title="Permalink to this heading">#</a></h2>
<p>En python, la función <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> de la librería <code class="docutils literal notranslate"><span class="pre">scipy.integrate</span></code> permite resolver sistemas de EDOs con valor inicial.</p>
<p>Considerando los argumentos mínimos para llamar la función:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">solve_ipv</span>
<span class="n">solve_ipv</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span><span class="n">t_span</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
</pre></div>
</div>
<p>donde:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fun</span></code>: (<em>callable</em>) función <span class="math notranslate nohighlight">\(F(t,\vec{y})\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t_span</span> <span class="pre">=</span> <span class="pre">(ti,</span> <span class="pre">tf)</span></code>: (<em>tupple</em>) intervalo entre el valor inicial (<code class="docutils literal notranslate"><span class="pre">ti</span></code>)  y final (<code class="docutils literal notranslate"><span class="pre">tf</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y0</span></code>: (<em>ndarray</em>) condición inicial <span class="math notranslate nohighlight">\(\vec{y}(0)\)</span></p></li>
</ul>
<p>La función posee 5 métodos disponibles, los cuales se pueden condicionar con un cuarto argumento <code class="docutils literal notranslate"><span class="pre">method</span></code>.</p>
<p>Entre los métodos disponibles tenemos:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">'RK45'</span></code>: <a class="reference external" href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method">Runge-Kutta 4(5) explícito</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">'RK23'</span></code>: <a class="reference external" href="https://en.wikipedia.org/wiki/Bogacki%E2%80%93Shampine_method">Runge-Kutta 2(3) explícito</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">'DOP853'</span></code>: <a class="reference external" href="http://www.unige.ch/~hairer/prog/nonstiff/dop853.f">Runge-Kutta 8 explícito</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">'Radau'</span></code>: <a class="reference external" href="https://en.wikipedia.org/wiki/List_of_Runge%E2%80%93Kutta_methods#Radau_IIA_methods">Runge-Kutta implícito de orden 5, conocido como Randau IIA</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">'BDF'</span></code>: <a class="reference external" href="https://en.wikipedia.org/wiki/Backward_differentiation_formula">Método multipaso implícito basado en derivadas hacia atrás</a>.</p></li>
</ul>
<p>Por defecto <code class="docutils literal notranslate"><span class="pre">method=RK45</span></code></p>
<p>También, al igual que con las librerías anteriores, podemos condicionar la tolerancia respecto al error relativo (<code class="docutils literal notranslate"><span class="pre">rtol</span></code>) y absoluto (<code class="docutils literal notranslate"><span class="pre">atol</span></code>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">solve_ipv</span>
<span class="n">solve_ipv</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span><span class="n">t_span</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1E-8</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1E-8</span><span class="p">)</span>  <span class="c1"># error absoluto y relativo menor a 1E-8</span>
</pre></div>
</div>
<p>Por defecto, <code class="docutils literal notranslate"><span class="pre">rtol</span> <span class="pre">=</span> <span class="pre">1E-3</span></code> y <code class="docutils literal notranslate"><span class="pre">atol</span> <span class="pre">=</span> <span class="pre">1E-6</span></code>.</p>
<p>Por ejemplo, consideremos la ecuación del péndulo:</p>
<p><strong>Ecuación gobernante</strong></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
ml\frac{d^2}{dt^2}\Theta(t) + \kappa\frac{d}{dt}\Theta(t) + mg \sin \Theta(t) = 0
\end{equation*}\]</div>
<p><strong>Condiciones iniciales</strong></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\dot{\Theta}(t = 0) &amp;= 0 \\
\Theta(t = 0) &amp;= \Theta_0
\end{align*}\]</div>
<p>Primero debemos transformar la ecuación a la forma <span class="math notranslate nohighlight">\(\frac{d}{dt}\vec{y} = F(t,\vec{y})\)</span>:</p>
<p><strong>Ecuación gobernante</strong></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\frac{d}{dt}
\left\{\begin{matrix}
\Theta(t) \\ \dot{\Theta}(t)
\end{matrix}\right\} =
\left\{\begin{matrix} 
\dot{\Theta} \\ - \frac{g}{l}\sin \Theta - \frac{\kappa}{ml}\dot{\Theta}
\end{matrix}\right\}
\end{equation*}\]</div>
<p><strong>Condiciones iniciales</strong></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\vec{y}(0) = \left\{\begin{matrix}
\Theta_0 \\ 0
\end{matrix}\right\}
\end{equation*}\]</div>
<p>Utilizamos <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> para resolver el sistema en el intervalo <span class="math notranslate nohighlight">\(t\in[0,5]\)</span> s. En este problema las constantes son <span class="math notranslate nohighlight">\(m = 200\)</span>g, <span class="math notranslate nohighlight">\(l = 30\)</span>cm, <span class="math notranslate nohighlight">\(\kappa = 0.1\)</span> kg/m<span class="math notranslate nohighlight">\(\cdot\)</span>s, <span class="math notranslate nohighlight">\(\Theta_0 = 30°\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">solve_ivp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">theta0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># condición inicial</span>

<span class="n">m</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># masa péndulo (kg)</span>
<span class="n">l</span> <span class="o">=</span> <span class="mf">0.3</span>  <span class="c1"># largo del péndulo (m)</span>
<span class="n">K</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="c1"># constante de amortiguación (kg/m*s)</span>
<span class="n">g</span> <span class="o">=</span> <span class="mf">9.8</span>  <span class="c1"># gravedad (m/s2)</span>
    
<span class="c1"># Definimos la función F(t,y)</span>
<span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>                              <span class="c1"># F0(t,y)</span>
            <span class="o">-</span> <span class="n">g</span><span class="o">/</span><span class="n">l</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">K</span><span class="o">/</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">l</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c1"># F1(t,y)</span>

<span class="c1"># Condicion inicial</span>
<span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">theta0</span><span class="p">,</span>   <span class="c1"># posición inicial</span>
               <span class="mi">0</span><span class="p">])</span>       <span class="c1"># velocidad inicial</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ti</span><span class="p">,</span> <span class="n">tf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>                       <span class="c1"># tiempo inicial (ti) y final (tf)</span>

<span class="c1"># resolvemos la EDO dy/dt = F(t,y)</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="n">fun</span>    <span class="o">=</span> <span class="n">F</span><span class="p">,</span>          <span class="c1"># Función F(t,y)</span>
                <span class="n">t_span</span> <span class="o">=</span> <span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">tf</span><span class="p">),</span>   <span class="c1"># Intervalo de tiempo</span>
                <span class="n">y0</span>     <span class="o">=</span> <span class="n">y0</span><span class="p">)</span>         <span class="c1"># Condición inicial</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>  message: The solver successfully reached the end of the integration interval.
  success: True
   status: 0
        t: [ 0.000e+00  1.753e-04 ...  4.955e+00  5.000e+00]
        y: [[ 1.745e-01  1.745e-01 ... -2.589e-03 -2.683e-03]
            [ 0.000e+00 -9.942e-04 ... -4.145e-03 -8.792e-05]]
      sol: None
 t_events: None
 y_events: None
     nfev: 230
     njev: 0
      nlu: 0
</pre></div>
</div>
</div>
</div>
<p>Notar que la variable <code class="docutils literal notranslate"><span class="pre">sol</span></code>, tiene una série de atributos que podemos llamar como <code class="docutils literal notranslate"><span class="pre">sol.</span></code><em>nombre_atributo</em>, donde <em>nombre_atributo</em>=<code class="docutils literal notranslate"><span class="pre">message</span></code>, <code class="docutils literal notranslate"><span class="pre">success</span></code>, <code class="docutils literal notranslate"><span class="pre">status</span></code>, etc.</p>
<p>La descripción de cada uno de estos atributos está en la <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp">documentación oficial de <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code></a></p>
<p>Las soluciones están en el arreglo <code class="docutils literal notranslate"><span class="pre">sol.y</span></code> y el paso de tiempo en el arreglo <code class="docutils literal notranslate"><span class="pre">sol.t</span></code>. Además, debido a que la solución está dada por <span class="math notranslate nohighlight">\(\vec{y} = \left\{\Theta, \dot{\Theta}\right\}\)</span>, la variable <code class="docutils literal notranslate"><span class="pre">sol.y</span></code> es un arreglo de dos filas.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tamaño arreglo t:&#39;</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tamaño arreglo y:&#39;</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Tamaño arreglo t: (36,)
Tamaño arreglo y: (2, 36)
</pre></div>
</div>
</div>
</div>
<p>Para conocer el ángulo <span class="math notranslate nohighlight">\(\Theta\)</span> y velocidad angular <span class="math notranslate nohighlight">\(\dot{\Theta}\)</span> para algún tiempo <span class="math notranslate nohighlight">\(t\)</span>, indexamos los arreglos <code class="docutils literal notranslate"><span class="pre">solt.t</span></code> y <code class="docutils literal notranslate"><span class="pre">sol.y</span></code>:</p>
<blockquote>
<div><p><strong>Nota</strong> Debido a que la solución está en radianes, usamos <code class="docutils literal notranslate"><span class="pre">numpy.degrees</span></code> para convertir a grados.</p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">idx</span> <span class="o">=</span> <span class="mi">30</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ángulo en t = </span><span class="si">%.1f</span><span class="s1">s: </span><span class="si">%.3f</span><span class="s1">°&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">idx</span><span class="p">])))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Velocidad angular en t = </span><span class="si">%.1f</span><span class="s1">s: </span><span class="si">%.3f</span><span class="s1">°/s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">idx</span><span class="p">])))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Ángulo en t = 4.3s: 0.148°
Velocidad angular en t = 4.3s: 1.226°/s
</pre></div>
</div>
</div>
</div>
<p>Notar, además, que en el <em>input</em> de la función solo indicamos el tiempo inicial y final, pero no especificamos el paso de tiempo <span class="math notranslate nohighlight">\(\Delta t\)</span>. Esto es porque, <strong>por defecto, <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> busca llegar al valor <code class="docutils literal notranslate"><span class="pre">tf</span></code> con el menor número de iteraciones.</strong></p>
<p>Así mismo, <strong>por defecto, el valor de <span class="math notranslate nohighlight">\(\Delta t\)</span> no es constante y se ajusta en cada iteración.</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># comprobamos dt usando numpy.diff</span>
<span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.00017528, 0.00175285, 0.01752846, 0.11998446, 0.16456768,
       0.1689104 , 0.16219921, 0.14826927, 0.14827456, 0.14679738,
       0.1661029 , 0.15676245, 0.17014528, 0.16059003, 0.15220766,
       0.15110048, 0.15110048, 0.16655107, 0.15621831, 0.17126165,
       0.16138863, 0.15310309, 0.15364646, 0.15364646, 0.1674564 ,
       0.15783907, 0.17254208, 0.16525935, 0.15145525, 0.17498422,
       0.15800762, 0.16629429, 0.16597964, 0.17287956, 0.04501803])
</pre></div>
</div>
</div>
</div>
<p>Graficamos la solución.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%capture</span> showplot0
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># transformamos el ángulo a grados</span>
<span class="n">theta</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
<span class="n">theta_dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">,:])</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span> <span class="c1"># Tamaño de fuente</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="p">,</span><span class="n">theta</span><span class="p">,</span> <span class="s1">&#39;:o&#39;</span><span class="p">,</span>    <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\Theta(t)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="p">,</span><span class="n">theta_dot</span><span class="p">,</span> <span class="s1">&#39;:o&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\dot{\Theta}(t)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$\Theta(t)$ (°)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Tiempo (s)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$\dot{\Theta}(t)$ (°/s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">showplot0</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/feb9a2e86ae3a042cf8b8b92075205e2ed7ec9078ad089b6b3c230613212ea0e.png" src="../_images/feb9a2e86ae3a042cf8b8b92075205e2ed7ec9078ad089b6b3c230613212ea0e.png" />
</div>
</div>
<p>Alternativamente, podemos definir los tiempos donde queremos conocer nuestra solución utilizando el argumento <code class="docutils literal notranslate"><span class="pre">t_eval</span></code>. Este argumento puede ser un valor específico o un arreglo.</p>
<p>Por ejemplo, consideremos <code class="docutils literal notranslate"><span class="pre">t_eval</span></code> como un arreglo en el dominio <span class="math notranslate nohighlight">\(t\in[0,5]\)</span> s con <span class="math notranslate nohighlight">\(\Delta t = 0.05\)</span> s.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">h</span> <span class="o">=</span> <span class="mf">0.05</span>                           <span class="c1"># paso de tiempo (s)</span>
<span class="n">t_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>         <span class="c1"># arreglo de tiempos a evaluar</span>
<span class="n">ti</span><span class="p">,</span> <span class="n">tf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>                     <span class="c1"># tiempo inicial (ti) y final (tf)</span>

<span class="c1"># Resolvemos la EDO dy/dt = F(t,y)</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="n">fun</span>    <span class="o">=</span> <span class="n">F</span><span class="p">,</span>        <span class="c1"># Función F(t,y)</span>
                <span class="n">t_span</span> <span class="o">=</span> <span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">tf</span><span class="p">),</span> <span class="c1"># Intervalo de tiempo</span>
                <span class="n">y0</span>     <span class="o">=</span> <span class="n">y0</span><span class="p">,</span>       <span class="c1"># Condición inicial</span>
                <span class="n">t_eval</span> <span class="o">=</span> <span class="n">t_array</span><span class="p">)</span>  <span class="c1"># Tiempos de evaluación de la solución</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%capture</span> showplot1
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># transformamos el ángulo a grados</span>
<span class="n">theta</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
<span class="n">theta_dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">,:])</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">})</span> <span class="c1"># Tamaño de fuente</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="p">,</span><span class="n">theta</span><span class="p">,</span> <span class="s1">&#39;:o&#39;</span><span class="p">,</span>    <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\Theta(t)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="p">,</span><span class="n">theta_dot</span><span class="p">,</span> <span class="s1">&#39;:o&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\dot{\Theta}(t)$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$\Theta(t)$ (°)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Tiempo (s)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$\dot{\Theta}(t)$ (°/s)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">showplot1</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/848a3944dafb426ca45575910937dcf526fa8e23848083c40f540c125294ecdf.png" src="../_images/848a3944dafb426ca45575910937dcf526fa8e23848083c40f540c125294ecdf.png" />
</div>
</div>
</section>
<section id="rigidez-en-edos">
<h2><span class="section-number">9.6. </span>Rigidez en EDOs<a class="headerlink" href="#rigidez-en-edos" title="Permalink to this heading">#</a></h2>
<section id="rigidez">
<h3><span class="section-number">9.6.1. </span>Rigidez<a class="headerlink" href="#rigidez" title="Permalink to this heading">#</a></h3>
<p>Una EDO se define como <em><strong>rígida</strong></em> si una de sus componentes cambia rápidamente respecto a otra. Esto provoca problemas de estabilidad en la solución.</p>
<p>Consideremos por ejemplo la ecuación:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\frac{dy}{dt} = - 1000y +3000-2000e^{-t}
\end{equation*}\]</div>
<p>con la condición inicial <span class="math notranslate nohighlight">\(y(0) = 0\)</span></p>
<p>La solución analítica a esta solución es:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
y = 3 - 0.998e^{-1000t} - 2.002e^{-t}
\end{equation*}\]</div>
<p>Al analizar la solución observamos que, al comienzo (<span class="math notranslate nohighlight">\(t &lt; 0.005\)</span>), la respuesta está mayormente respresentada por el término transitorio, <span class="math notranslate nohighlight">\(e^{-1000t}\)</span>. Luego, la respuesta comienza a ser dominada por el término <span class="math notranslate nohighlight">\(e^{-t}\)</span></p>
<a class="reference internal image-reference" href="../_images/stiffness.png"><img alt="../_images/stiffness.png" class="align-center" src="../_images/stiffness.png" style="width: 350px;" /></a>
<p>Como el método no conoce la solución analítica, el término transitorio genera problemas de inestabilidad si el valor de <span class="math notranslate nohighlight">\(\Delta t\)</span> es muy grande; o de convergencia, si <span class="math notranslate nohighlight">\(\Delta t\)</span> es muy pequeño.</p>
</section>
<section id="recomendaciones">
<h3><span class="section-number">9.6.2. </span>Recomendaciones<a class="headerlink" href="#recomendaciones" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><strong>Para EDOs no rígidas</strong>, se recomiendan los métodos <code class="docutils literal notranslate"><span class="pre">RK45</span></code>, <code class="docutils literal notranslate"><span class="pre">RK23</span></code> y <code class="docutils literal notranslate"><span class="pre">DOP853</span></code>.</p></li>
<li><p><strong>Para EDOs rígidas</strong>, se recomienda los métodos <code class="docutils literal notranslate"><span class="pre">Radau</span></code> y <code class="docutils literal notranslate"><span class="pre">BDF</span></code>.</p></li>
</ul>
<p>Como regla general, se recomienda intentar con un método explícito (como <code class="docutils literal notranslate"><span class="pre">RK45</span></code>). Si la solución diverge o tiene un comportamiento inusual, es probable la EDO sea rígida y, en ese caso, se debe utilizar un método implícito de paso simple (<code class="docutils literal notranslate"><span class="pre">Radau</span></code>) o multipaso (<code class="docutils literal notranslate"><span class="pre">BDF</span></code>).</p>
<p>Revisemos esto analizando la siguiente EDO en el intervalo <span class="math notranslate nohighlight">\(t\in[0,10]\)</span>:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\frac{dy}{dt} = - 100000\left(y - \cos t\right),\quad y(0) = 1
\end{equation*}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Definimos nuestra EDO en código</span>
<span class="n">ti</span><span class="p">,</span> <span class="n">tf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>                            <span class="c1"># intervalo de tiempo</span>
<span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="o">-</span> <span class="mi">100000</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="c1"># función F(t,y)</span>
</pre></div>
</div>
</div>
</div>
<p>Compararemos el tiempo de cómputo y el tamaño del arreglo <code class="docutils literal notranslate"><span class="pre">sol.t</span></code> cuando usamos:</p>
<ul class="simple">
<li><p>Método de paso simple explícito (<code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">RK45</span></code>)</p></li>
<li><p>Método de paso simple implícito (<code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">Radau</span></code>)</p></li>
<li><p>Método de paso múltiple implícito (<code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">BDF</span></code>)</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Usamos method = RK45</span>
<span class="o">%</span><span class="k">time</span> sol = solve_ivp(fun = F,t_span = (ti, tf), y0 = [1], method = &#39;RK45&#39;)
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Número de subdivisiones de variable &quot;t&quot;: </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>CPU times: user 13.3 s, sys: 62.2 ms, total: 13.3 s
Wall time: 14.4 s
Número de subdivisiones de variable &quot;t&quot;: 302037
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Usamos method = BDF</span>
<span class="o">%</span><span class="k">time</span> sol = solve_ivp(fun = F,t_span = (ti, tf), y0 = [1], method = &#39;BDF&#39;)
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Número de subdivisiones de variable &quot;t&quot;: </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>CPU times: user 7.24 ms, sys: 0 ns, total: 7.24 ms
Wall time: 8.43 ms
Número de subdivisiones de variable &quot;t&quot;: 56
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Usamos method = Radau</span>
<span class="o">%</span><span class="k">time</span> sol = solve_ivp(fun = F,t_span = (ti, tf), y0 = [1], method = &#39;Radau&#39;)
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Número de subdivisiones de variable &quot;t&quot;: </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>CPU times: user 3.19 ms, sys: 37 µs, total: 3.23 ms
Wall time: 6.12 ms
Número de subdivisiones de variable &quot;t&quot;: 7
</pre></div>
</div>
</div>
</div>
<p>Como vemos, el tiempo de cómputo y el número de subdivisiones con los métodos implícitos <code class="docutils literal notranslate"><span class="pre">Radau</span></code> y <code class="docutils literal notranslate"><span class="pre">BDF</span></code> es significativamente menor, en comparación con métodos de paso simple (como <code class="docutils literal notranslate"><span class="pre">RK45</span></code>).</p>
</section>
</section>
<section id="referencias">
<h2><span class="section-number">9.7. </span>Referencias<a class="headerlink" href="#referencias" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>Kong Q., Siauw T., Bayen A. M. <strong>Chapter 22: ODEs Initial-Value Problems</strong> in <em><a class="reference external" href="https://pythonnumericalmethods.berkeley.edu/notebooks/chapter22.00-ODE-Initial-Value-Problems.html">Python Programming and Numerical Methods – A Guide for Engineers and Scientists</a></em>, 1st Ed., Academic Press, 2021</p></li>
<li><p>Chapra S., Canale R. <strong>Capítulo 25: Métodos de Runge-Kutta</strong> en <em>Métodos Numéricos para Ingenieros</em>, 6ta Ed., McGraw Hill, 2011</p></li>
<li><p>Chapra S., Canale R. <strong>Capítulo 26: Métodos rígidos y de paso múltiple</strong> en <em>Métodos Numéricos para Ingenieros</em>, 6ta Ed., McGraw Hill, 2011</p></li>
<li><p>Williams H. P. <strong>Chapter 17: Integration of Ordinary Differential Equations</strong> in “Numerical Recipes” 3rd Ed, Cambridge University Press, 2007</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./09-EDO_valor_inicial"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../08-Derivacion_numerica/08-Derivacion_numerica.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">8. </span>Derivación numérica</p>
      </div>
    </a>
    <a class="right-next"
       href="../10-EDO_condicion_de_borde/10-EDO_condicion_de_borde.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">10. </span>Problema de valor en la frontera</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduccion">9.1. Introducción</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#clasificacion-de-ecuaciones-diferenciales">9.1.1. Clasificación de ecuaciones diferenciales</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#condiciones-de-borde-y-condiciones-iniciales">9.1.2. Condiciones de borde y condiciones iniciales</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#aspectos-generales-de-los-metodos-numericos-para-solucion-de-odes">9.2. Aspectos generales de los métodos numéricos para solución de ODEs</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ecuacion-diferencial-ordinaria-edo-con-valor-inicial">9.2.1. Ecuación diferencial ordinaria (EDO) con valor inicial</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodo-de-euler-explicito">9.2.2. Método de Euler explícito</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#presicion">9.2.3. Presición</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#estabilidad">9.2.4. Estabilidad</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#metodo-de-euler-implicito">9.2.5. Método de Euler implícito</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metodos-de-paso-simple-runge-kutta">9.3. Métodos de paso simple (Runge-Kutta)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#runge-kutta-de-segundo-orden-rk2">9.3.1. Runge-Kutta de segundo orden (RK2)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#runge-kutta-de-cuarto-orden-rk4">9.3.2. Runge-Kutta de cuarto orden (RK4)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#metodos-multipasos">9.4. Métodos multipasos</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solucion-de-edos-en-python-scipy-integrate-solve-ivp">9.5. Solución de EDOs en python (<code class="docutils literal notranslate"><span class="pre">scipy.integrate.solve_ivp</span></code>)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rigidez-en-edos">9.6. Rigidez en EDOs</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rigidez">9.6.1. Rigidez</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#recomendaciones">9.6.2. Recomendaciones</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#referencias">9.7. Referencias</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Francisco V. Ramirez-Cuevas
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>